// Code generated by Forge Service
// DO NOT EDIT

package forge_example

import (
	"context"
	"fmt"
	"time"

	"UptimePingPlatform/services/core-service/internal/domain"
	"UptimePingPlatform/pkg/logger"
	grpcBase "UptimePingPlatform/pkg/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/health/grpc_health_v1"
)

// ForgeServiceChecker реализует Checker для gRPC сервиса ForgeService
type ForgeServiceChecker struct {
	*grpcBase.BaseHandler
	conn   *grpc.ClientConn
	client grpc_health_v1.HealthClient
	logger logger.Logger
}

// NewForgeServiceChecker создает новый экземпляр checker'а
func NewForgeServiceChecker(timeout int64, log logger.Logger) *ForgeServiceChecker {
	return &ForgeServiceChecker{
		BaseHandler: grpcBase.NewBaseHandler(log),
		logger:      log,
	}
}

// Execute выполняет проверку gRPC сервиса
func (c *ForgeServiceChecker) Execute(task *domain.Task) (*domain.CheckResult, error) {
	c.LogOperationStart(context.Background(), "grpc_check", map[string]interface{}{
		"service": "ForgeService",
		"target":  task.Target,
		"check_id": task.CheckID,
	})

	startTime := time.Now()
	
	// Подключаемся к gRPC сервису
	conn, err := grpc.Dial(task.Target, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		duration := time.Since(startTime)
		result := c.createErrorResult(task, 0, duration.Milliseconds(), fmt.Errorf("failed to connect: %w", err))
		c.LogOperationError(context.Background(), "grpc_check", err, map[string]interface{}{
			"target": task.Target,
			"error":  err.Error(),
		})
		return result, nil
	}
	defer conn.Close()

	// Создаем health client
	client := grpc_health_v1.NewHealthClient(conn)

	// Выполняем health check
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Second)
	defer cancel()

	req := &grpc_health_v1.HealthCheckRequest{
		Service: "forge.example.ForgeService",
	}

	resp, err := client.Check(ctx, req)
	if err != nil {
		duration := time.Since(startTime)
		result := c.createErrorResult(task, 0, duration.Milliseconds(), fmt.Errorf("health check failed: %w", err))
		c.LogOperationError(context.Background(), "grpc_check", err, map[string]interface{}{
			"service": "ForgeService",
			"error":   err.Error(),
		})
		return result, nil
	}

	duration := time.Since(startTime)
	success := resp.Status == grpc_health_v1.HealthCheckResponse_SERVING

	result := &domain.CheckResult{
		CheckID:      task.CheckID,
		ExecutionID:   task.ExecutionID,
		Type:         task.Type,
		Target:       task.Target,
		Success:      success,
		StatusCode:   c.getStatusCode(resp.Status),
		ResponseTime:  duration.Milliseconds(),
		CheckedAt:    time.Now().UTC(),
		Metadata:     make(map[string]string),
	}

	// Добавляем метаданные
	result.Metadata["service"] = "ForgeService"
	result.Metadata["package"] = "forge.example"
	result.Metadata["status"] = resp.Status.String()
	result.Metadata["grpc_target"] = task.Target

	if !success {
		result.Error = fmt.Sprintf("Service status: %s", resp.Status.String())
	}

	c.LogOperationSuccess(context.Background(), "grpc_check", map[string]interface{}{
		"service":   "ForgeService",
		"target":    task.Target,
		"success":   success,
		"duration":  duration.Milliseconds(),
		"status":    resp.Status.String(),
	})

	return result, nil
}

// GetType возвращает тип checker'а
func (c *ForgeServiceChecker) GetType() domain.TaskType {
	return domain.TaskTypeGRPC
}

// ValidateConfig валидирует конфигурацию
func (c *ForgeServiceChecker) ValidateConfig(config map[string]interface{}) error {
	requiredFields := map[string]string{
		"service": "gRPC service name",
		"host":    "gRPC service host",
		"port":    "gRPC service port",
	}

	if err := c.BaseHandler.ValidateRequiredFields(config, requiredFields); err != nil {
		c.logger.Debug("ForgeService config validation failed", logger.Error(err))
		return err
	}

	// Валидация порта
	port, ok := config["port"]
	if !ok {
		return fmt.Errorf("port is required")
	}

	portFloat, ok := port.(float64)
	if !ok {
		return fmt.Errorf("port must be a number")
	}

	portInt := int(portFloat)
	if portInt < 1 || portInt > 65535 {
		return fmt.Errorf("port must be between 1 and 65535")
	}

	// Валидация таймаута
	if timeout, ok := config["timeout"]; ok {
		if timeoutStr, ok := timeout.(string); ok {
			if _, err := time.ParseDuration(timeoutStr); err != nil {
				return fmt.Errorf("invalid timeout format: %s", timeoutStr)
			}
		}
	}

	c.logger.Debug("ForgeService config validation passed")
	return nil
}

// getStatusCode конвертирует gRPC health status в HTTP статус код
func (c *ForgeServiceChecker) getStatusCode(status grpc_health_v1.HealthCheckResponse_ServingStatus) int {
	switch status {
	case grpc_health_v1.HealthCheckResponse_SERVING:
		return 200
	case grpc_health_v1.HealthCheckResponse_NOT_SERVING:
		return 503
	case grpc_health_v1.HealthCheckResponse_SERVICE_UNKNOWN:
		return 503
	default:
		return 500
	}
}

// createErrorResult создает результат с ошибкой
func (c *ForgeServiceChecker) createErrorResult(task *domain.Task, statusCode int, responseTime int64, err error) *domain.CheckResult {
	return &domain.CheckResult{
		CheckID:      task.CheckID,
		ExecutionID:   task.ExecutionID,
		Type:         task.Type,
		Target:       task.Target,
		Success:      false,
		StatusCode:   statusCode,
		ResponseTime:  responseTime,
		Error:        err.Error(),
		CheckedAt:    time.Now().UTC(),
		Metadata:     make(map[string]string),
	}
}


// CreateConfigChecker выполняет проверку конкретного метода CreateConfig
func (c *ForgeServiceChecker) CheckCreateConfig(ctx context.Context, target string) (*domain.CheckResult, error) {
	task := domain.NewTask(
		"check-CreateConfig",
		target,
		"grpc",
		"exec-CreateConfig",
		time.Now(),
		map[string]interface{}{
			"service": "forge.example.ForgeService",
			"method":  "CreateConfig",
			"timeout": "30s",
		},
	)
	
	return c.Execute(task)
}

// GetConfigChecker выполняет проверку конкретного метода GetConfig
func (c *ForgeServiceChecker) CheckGetConfig(ctx context.Context, target string) (*domain.CheckResult, error) {
	task := domain.NewTask(
		"check-GetConfig",
		target,
		"grpc",
		"exec-GetConfig",
		time.Now(),
		map[string]interface{}{
			"service": "forge.example.ForgeService",
			"method":  "GetConfig",
			"timeout": "30s",
		},
	)
	
	return c.Execute(task)
}

// UpdateConfigChecker выполняет проверку конкретного метода UpdateConfig
func (c *ForgeServiceChecker) CheckUpdateConfig(ctx context.Context, target string) (*domain.CheckResult, error) {
	task := domain.NewTask(
		"check-UpdateConfig",
		target,
		"grpc",
		"exec-UpdateConfig",
		time.Now(),
		map[string]interface{}{
			"service": "forge.example.ForgeService",
			"method":  "UpdateConfig",
			"timeout": "30s",
		},
	)
	
	return c.Execute(task)
}

// DeleteConfigChecker выполняет проверку конкретного метода DeleteConfig
func (c *ForgeServiceChecker) CheckDeleteConfig(ctx context.Context, target string) (*domain.CheckResult, error) {
	task := domain.NewTask(
		"check-DeleteConfig",
		target,
		"grpc",
		"exec-DeleteConfig",
		time.Now(),
		map[string]interface{}{
			"service": "forge.example.ForgeService",
			"method":  "DeleteConfig",
			"timeout": "30s",
		},
	)
	
	return c.Execute(task)
}

// ListConfigsChecker выполняет проверку конкретного метода ListConfigs
func (c *ForgeServiceChecker) CheckListConfigs(ctx context.Context, target string) (*domain.CheckResult, error) {
	task := domain.NewTask(
		"check-ListConfigs",
		target,
		"grpc",
		"exec-ListConfigs",
		time.Now(),
		map[string]interface{}{
			"service": "forge.example.ForgeService",
			"method":  "ListConfigs",
			"timeout": "30s",
		},
	)
	
	return c.Execute(task)
}

// ValidateConfigChecker выполняет проверку конкретного метода ValidateConfig
func (c *ForgeServiceChecker) CheckValidateConfig(ctx context.Context, target string) (*domain.CheckResult, error) {
	task := domain.NewTask(
		"check-ValidateConfig",
		target,
		"grpc",
		"exec-ValidateConfig",
		time.Now(),
		map[string]interface{}{
			"service": "forge.example.ForgeService",
			"method":  "ValidateConfig",
			"timeout": "30s",
		},
	)
	
	return c.Execute(task)
}

