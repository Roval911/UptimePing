// Code generated by Forge Service
// DO NOT EDIT

package forge_example

import (
	"context"
	"fmt"
	"time"

	"UptimePingPlatform/gen/go/proto/api/core/v1"
	"UptimePingPlatform/pkg/logger"
	grpcBase "UptimePingPlatform/pkg/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/health/grpc_health_v1"
)

// Task представляет задачу на выполнение проверки
type Task struct {
	ID           string `json:"id"`
	CheckID      string `json:"check_id"`
	Target       string `json:"target"`
	Type         string `json:"type"`
	ExecutionID  string `json:"execution_id"`
}

// TaskType представляет тип задачи
type TaskType string

const (
	TaskTypeHTTP   TaskType = "http"
	TaskTypeTCP    TaskType = "tcp"
	TaskTypeGRPC   TaskType = "grpc"
	TaskTypeICMP   TaskType = "icmp"
	TaskTypeGraphQL TaskType = "graphql"
)

// CheckResult представляет результат выполнения проверки
type CheckResult struct {
	ID           string            `json:"id"`
	CheckID      string            `json:"check_id"`
	ExecutionID  string            `json:"execution_id"`
	Type         string            `json:"type"`
	Success      bool              `json:"success"`
	Status       string            `json:"status"`
	ResponseTime int64             `json:"response_time"`
	ErrorMessage string            `json:"error_message,omitempty"`
	Timestamp    time.Time         `json:"timestamp"`
	Metadata     map[string]interface{} `json:"metadata,omitempty"`
}

// NewTask создает новую задачу
func NewTask(checkID, target, taskType string) *Task {
	return &Task{
		ID:           fmt.Sprintf("task-%d", time.Now().UnixNano()),
		CheckID:      checkID,
		Target:       target,
		Type:         taskType,
		ExecutionID:  fmt.Sprintf("exec-%d", time.Now().UnixNano()),
	}
}

// ForgeServiceChecker реализует Checker для gRPC сервиса ForgeService
type ForgeServiceChecker struct {
	*grpcBase.BaseHandler
	conn   *grpc.ClientConn
	client grpc_health_v1.HealthClient
	logger logger.Logger
}

// NewForgeServiceChecker создает новый экземпляр checker'а
func NewForgeServiceChecker(timeout int64, log logger.Logger) *ForgeServiceChecker {
	return &ForgeServiceChecker{
		BaseHandler: grpcBase.NewBaseHandler(log),
		logger:      log,
	}
}

// Execute выполняет проверку gRPC сервиса
func (c *ForgeServiceChecker) Execute(task *Task) (*CheckResult, error) {
	c.LogOperationStart(context.Background(), "grpc_check", map[string]interface{}{
		"service": "ForgeService",
		"target":  task.Target,
		"check_id": task.CheckID,
	})

	startTime := time.Now()
	
	// Подключаемся к gRPC сервису
	conn, err := grpc.Dial(task.Target, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		duration := time.Since(startTime)
		result := c.createErrorResult(task, 0, duration.Milliseconds(), fmt.Errorf("failed to connect: %w", err))
		c.LogOperationError(context.Background(), "grpc_check", err, map[string]interface{}{
			"target": task.Target,
			"error":  err.Error(),
		})
		return result, nil
	}
	defer conn.Close()

	// Создаем health client
	client := grpc_health_v1.NewHealthClient(conn)

	// Выполняем health check
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Second)
	defer cancel()

	req := &grpc_health_v1.HealthCheckRequest{
		Service: "forge.example.ForgeService",
	}

	resp, err := client.Check(ctx, req)
	if err != nil {
		duration := time.Since(startTime)
		result := c.createErrorResult(task, 0, duration.Milliseconds(), fmt.Errorf("health check failed: %w", err))
		c.LogOperationError(context.Background(), "grpc_check", err, map[string]interface{}{
			"service": "ForgeService",
			"error":   err.Error(),
		})
		return result, nil
	}

	duration := time.Since(startTime)
	success := resp.Status == grpc_health_v1.HealthCheckResponse_SERVING

	result := &CheckResult{
		CheckID:      task.CheckID,
		ExecutionID:   task.ExecutionID,
		Type:         task.Type,
		Target:       task.Target,
		Success:      success,
		StatusCode:   c.getStatusCode(resp.Status),
		ResponseTime:  duration.Milliseconds(),
		CheckedAt:    time.Now().UTC(),
		Metadata:     make(map[string]string),
	}

	// Добавляем метаданные
	result.Metadata["service"] = "ForgeService"
	result.Metadata["package"] = "forge.example"
	result.Metadata["status"] = resp.Status.String()
	result.Metadata["grpc_target"] = task.Target

	if !success {
		result.Error = fmt.Sprintf("Service status: %s", resp.Status.String())
	}

	c.LogOperationSuccess(context.Background(), "grpc_check", map[string]interface{}{
		"service":   "ForgeService",
		"target":    task.Target,
		"success":   success,
		"duration":  duration.Milliseconds(),
		"status":    resp.Status.String(),
	})

	return result, nil
}

// GetType возвращает тип checker'а
func (c *ForgeServiceChecker) GetType() TaskType {
	return TaskTypeGRPC
}

// ValidateConfig валидирует конфигурацию
func (c *ForgeServiceChecker) ValidateConfig(config map[string]interface{}) error {
	requiredFields := map[string]string{
		"service": "gRPC service name",
		"host":    "gRPC service host",
		"port":    "gRPC service port",
	}

	if err := c.BaseHandler.ValidateRequiredFields(config, requiredFields); err != nil {
		c.logger.Debug("ForgeService config validation failed", logger.Error(err))
		return err
	}

	// Валидация порта
	port, ok := config["port"]
	if !ok {
		return fmt.Errorf("port is required")
	}

	portFloat, ok := port.(float64)
	if !ok {
		return fmt.Errorf("port must be a number")
	}

	portInt := int(portFloat)
	if portInt < 1 || portInt > 65535 {
		return fmt.Errorf("port must be between 1 and 65535")
	}

	// Валидация таймаута
	if timeout, ok := config["timeout"]; ok {
		if timeoutStr, ok := timeout.(string); ok {
			if _, err := time.ParseDuration(timeoutStr); err != nil {
				return fmt.Errorf("invalid timeout format: %s", timeoutStr)
			}
		}
	}

	c.logger.Debug("ForgeService config validation passed")
	return nil
}

// getStatusCode конвертирует gRPC health status в HTTP статус код
func (c *ForgeServiceChecker) getStatusCode(status grpc_health_v1.HealthCheckResponse_ServingStatus) int {
	switch status {
	case grpc_health_v1.HealthCheckResponse_SERVING:
		return 200
	case grpc_health_v1.HealthCheckResponse_NOT_SERVING:
		return 503
	case grpc_health_v1.HealthCheckResponse_SERVICE_UNKNOWN:
		return 503
	default:
		return 500
	}
}

// createErrorResult создает результат с ошибкой
func (c *ForgeServiceChecker) createErrorResult(task *Task, statusCode int, responseTime int64, err error) *CheckResult {
	return &CheckResult{
		CheckID:      task.CheckID,
		ExecutionID:   task.ExecutionID,
		Type:         task.Type,
		Target:       task.Target,
		Success:      false,
		StatusCode:   statusCode,
		ResponseTime:  responseTime,
		Error:        err.Error(),
		CheckedAt:    time.Now().UTC(),
		Metadata:     make(map[string]string),
	}
}


// CreateConfigChecker выполняет проверку конкретного метода CreateConfig
func (c *ForgeServiceChecker) CheckCreateConfig(ctx context.Context, target string) (*CheckResult, error) {
	task := NewTask(
		"check-CreateConfig",
		target,
		"grpc",
	)
	
	return c.Execute(task)
}

// GetConfigChecker выполняет проверку конкретного метода GetConfig
func (c *ForgeServiceChecker) CheckGetConfig(ctx context.Context, target string) (*CheckResult, error) {
	task := NewTask(
		"check-GetConfig",
		target,
		"grpc",
	)
	
	return c.Execute(task)
}

// UpdateConfigChecker выполняет проверку конкретного метода UpdateConfig
func (c *ForgeServiceChecker) CheckUpdateConfig(ctx context.Context, target string) (*CheckResult, error) {
	task := NewTask(
		"check-UpdateConfig",
		target,
		"grpc",
	)
	
	return c.Execute(task)
}

// DeleteConfigChecker выполняет проверку конкретного метода DeleteConfig
func (c *ForgeServiceChecker) CheckDeleteConfig(ctx context.Context, target string) (*CheckResult, error) {
	task := NewTask(
		"check-DeleteConfig",
		target,
		"grpc",
	)
	
	return c.Execute(task)
}

// ListConfigsChecker выполняет проверку конкретного метода ListConfigs
func (c *ForgeServiceChecker) CheckListConfigs(ctx context.Context, target string) (*CheckResult, error) {
	task := NewTask(
		"check-ListConfigs",
		target,
		"grpc",
	)
	
	return c.Execute(task)
}

// ValidateConfigChecker выполняет проверку конкретного метода ValidateConfig
func (c *ForgeServiceChecker) CheckValidateConfig(ctx context.Context, target string) (*CheckResult, error) {
	task := NewTask(
		"check-ValidateConfig",
		target,
		"grpc",
	)
	
	return c.Execute(task)
}

