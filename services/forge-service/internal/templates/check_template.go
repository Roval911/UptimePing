package templates

import (
	"text/template"
)

// TemplateManager управляет шаблонами для генерации кода
type TemplateManager struct {
	configTemplate *template.Template
	grpcTemplate   *template.Template
}

// NewTemplateManager создает новый менеджер шаблонов
func NewTemplateManager() *TemplateManager {
	return &TemplateManager{
		configTemplate: createConfigTemplate(),
		grpcTemplate:   createGRPCTemplate(),
	}
}

// GetConfigTemplate возвращает шаблон для YAML конфигурации
func (tm *TemplateManager) GetConfigTemplate() (*template.Template, error) {
	return tm.configTemplate, nil
}

// GetGRPCTemplate возвращает шаблон для gRPC checker'а
func (tm *TemplateManager) GetGRPCTemplate() (*template.Template, error) {
	return tm.grpcTemplate, nil
}

// createConfigTemplate создает шаблон для YAML конфигурации
func createConfigTemplate() *template.Template {
	const configTemplate = `# UptimePing Core Configuration
# Generated by Forge Service

# gRPC Services Configuration
grpc_services:
{{- range .Services}}
  - name: "{{.Name}}"
    package: "{{.Package}}"
    host: "{{.Host}}"
    port: {{.Port}}
    methods:
{{- range .Methods}}
      - name: "{{.Name}}"
        timeout: "{{.Timeout}}"
        enabled: {{.Enabled}}
{{- end}}
{{- end}}

# Check Configuration
checks:
{{- range .Services}}
{{- range .Methods}}
  - name: "{{$.Name}}.{{.Name}}"
    type: "grpc"
    target: "{{$.Host}}:{{$.Port}}"
    service: "{{$.Package}}.{{$.Name}}"
    method: "{{.Name}}"
    timeout: "{{.Timeout}}"
    interval: "30s"
    enabled: {{.Enabled}}
{{- end}}
{{- end}}

# Global Settings
global:
  timeout: "30s"
  interval: "30s"
  retries: 3
  backoff: "1s"
`

	return template.Must(template.New("config").Parse(configTemplate))
}

// createGRPCTemplate создает шаблон для gRPC checker'а
func createGRPCTemplate() *template.Template {
	const grpcTemplate = `// Code generated by Forge Service
// DO NOT EDIT

package {{.PackageName}}

import (
	"context"
	"fmt"
	"time"

	"UptimePingPlatform/services/core-service/internal/domain"
	"UptimePingPlatform/pkg/logger"
	grpcBase "UptimePingPlatform/pkg/grpc"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/grpc/health/grpc_health_v1"
)

// {{.CheckerName}} реализует Checker для gRPC сервиса {{.Service.Name}}
type {{.CheckerName}} struct {
	*grpcBase.BaseHandler
	conn   *grpc.ClientConn
	client grpc_health_v1.HealthClient
	logger logger.Logger
}

// New{{.CheckerName}} создает новый экземпляр checker'а
func New{{.CheckerName}}(timeout int64, log logger.Logger) *{{.CheckerName}} {
	return &{{.CheckerName}}{
		BaseHandler: grpcBase.NewBaseHandler(log),
		logger:      log,
	}
}

// Execute выполняет проверку gRPC сервиса
func (c *{{.CheckerName}}) Execute(task *domain.Task) (*domain.CheckResult, error) {
	c.LogOperationStart(context.Background(), "grpc_check", map[string]interface{}{
		"service": "{{.Service.Name}}",
		"target":  task.Target,
		"check_id": task.CheckID,
	})

	startTime := time.Now()
	
	// Подключаемся к gRPC сервису
	conn, err := grpc.Dial(task.Target, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		duration := time.Since(startTime)
		result := c.createErrorResult(task, 0, duration.Milliseconds(), fmt.Errorf("failed to connect: %w", err))
		c.LogOperationError(context.Background(), "grpc_check", err, map[string]interface{}{
			"target": task.Target,
			"error":  err.Error(),
		})
		return result, nil
	}
	defer conn.Close()

	// Создаем health client
	client := grpc_health_v1.NewHealthClient(conn)

	// Выполняем health check
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(timeout)*time.Second)
	defer cancel()

	req := &grpc_health_v1.HealthCheckRequest{
		Service: "{{.Service.Package}}.{{.Service.Name}}",
	}

	resp, err := client.Check(ctx, req)
	if err != nil {
		duration := time.Since(startTime)
		result := c.createErrorResult(task, 0, duration.Milliseconds(), fmt.Errorf("health check failed: %w", err))
		c.LogOperationError(context.Background(), "grpc_check", err, map[string]interface{}{
			"service": "{{.Service.Name}}",
			"error":   err.Error(),
		})
		return result, nil
	}

	duration := time.Since(startTime)
	success := resp.Status == grpc_health_v1.HealthCheckResponse_SERVING

	result := &domain.CheckResult{
		CheckID:      task.CheckID,
		ExecutionID:   task.ExecutionID,
		Type:         task.Type,
		Target:       task.Target,
		Success:      success,
		StatusCode:   c.getStatusCode(resp.Status),
		ResponseTime:  duration.Milliseconds(),
		CheckedAt:    time.Now().UTC(),
		Metadata:     make(map[string]string),
	}

	// Добавляем метаданные
	result.Metadata["service"] = "{{.Service.Name}}"
	result.Metadata["package"] = "{{.Service.Package}}"
	result.Metadata["status"] = resp.Status.String()
	result.Metadata["grpc_target"] = task.Target

	if !success {
		result.Error = fmt.Sprintf("Service status: %s", resp.Status.String())
	}

	c.LogOperationSuccess(context.Background(), "grpc_check", map[string]interface{}{
		"service":   "{{.Service.Name}}",
		"target":    task.Target,
		"success":   success,
		"duration":  duration.Milliseconds(),
		"status":    resp.Status.String(),
	})

	return result, nil
}

// GetType возвращает тип checker'а
func (c *{{.CheckerName}}) GetType() domain.TaskType {
	return domain.TaskTypeGRPC
}

// ValidateConfig валидирует конфигурацию
func (c *{{.CheckerName}}) ValidateConfig(config map[string]interface{}) error {
	requiredFields := map[string]string{
		"service": "gRPC service name",
		"host":    "gRPC service host",
		"port":    "gRPC service port",
	}

	if err := c.BaseHandler.ValidateRequiredFields(config, requiredFields); err != nil {
		c.logger.Debug("{{.Service.Name}} config validation failed", logger.Error(err))
		return err
	}

	// Валидация порта
	port, ok := config["port"]
	if !ok {
		return fmt.Errorf("port is required")
	}

	portFloat, ok := port.(float64)
	if !ok {
		return fmt.Errorf("port must be a number")
	}

	portInt := int(portFloat)
	if portInt < 1 || portInt > 65535 {
		return fmt.Errorf("port must be between 1 and 65535")
	}

	// Валидация таймаута
	if timeout, ok := config["timeout"]; ok {
		if timeoutStr, ok := timeout.(string); ok {
			if _, err := time.ParseDuration(timeoutStr); err != nil {
				return fmt.Errorf("invalid timeout format: %s", timeoutStr)
			}
		}
	}

	c.logger.Debug("{{.Service.Name}} config validation passed")
	return nil
}

// getStatusCode конвертирует gRPC health status в HTTP статус код
func (c *{{.CheckerName}}) getStatusCode(status grpc_health_v1.HealthCheckResponse_ServingStatus) int {
	switch status {
	case grpc_health_v1.HealthCheckResponse_SERVING:
		return 200
	case grpc_health_v1.HealthCheckResponse_NOT_SERVING:
		return 503
	case grpc_health_v1.HealthCheckResponse_SERVICE_UNKNOWN:
		return 503
	default:
		return 500
	}
}

// createErrorResult создает результат с ошибкой
func (c *{{.CheckerName}}) createErrorResult(task *domain.Task, statusCode int, responseTime int64, err error) *domain.CheckResult {
	return &domain.CheckResult{
		CheckID:      task.CheckID,
		ExecutionID:   task.ExecutionID,
		Type:         task.Type,
		Target:       task.Target,
		Success:      false,
		StatusCode:   statusCode,
		ResponseTime:  responseTime,
		Error:        err.Error(),
		CheckedAt:    time.Now().UTC(),
		Metadata:     make(map[string]string),
	}
}

{{range .Service.Methods}}
// {{.Name}}Checker выполняет проверку конкретного метода {{.Name}}
func (c *{{$.CheckerName}}) Check{{.Name}}(ctx context.Context, target string) (*domain.CheckResult, error) {
	task := domain.NewTask(
		"check-{{.Name}}",
		target,
		"grpc",
		"exec-{{.Name}}",
		time.Now(),
		map[string]interface{}{
			"service": "{{$.Service.Package}}.{{$.Service.Name}}",
			"method":  "{{.Name}}",
			"timeout": "{{.Timeout}}",
		},
	)
	
	return c.Execute(task)
}
{{end}}
`

	return template.Must(template.New("grpc_checker").Parse(grpcTemplate))
}
