
# UptimePing Platform - Архитектура

## Обзор системы

UptimePing Platform состоит из двух продуктов:
- **UptimePing Core**: Продакшен-готовый мониторинг для HTTP/HTTPS, gRPC, GraphQL и TCP с мультитенантной архитектурой и расширенными уведомлениями
- **UptimePing Forge**: Инструмент для автоматической генерации конфигурации и кода проверок из .proto файлов с интерактивной настройкой

**Обновление**: Добавлен **CLI Service** для управления платформой через командную строку.

## Микросервисная архитектура (10 сервисов)

### 1. API Gateway Service
**Назначение**: Единая точка входа для всех внешних запросов, маршрутизация, аутентификация, rate limiting, CORS, балансировка нагрузки

**Технологии**: 
- HTTP REST API (Gin/Chi)
- gRPC клиенты для всех внутренних сервисов
- JWT валидация токенов + API Key аутентификация
- Client-side load balancing
- Circuit breaker паттерн

**Порты**: 
- HTTP: 8080 (публичный API)
- gRPC: 9090 (внутренний, для service mesh)
- Health: 8081 (health checks)

**Зависимости**: 
- Auth Service (валидация токенов и API ключей)
- Все остальные сервисы (маршрутизация)

**gRPC интерцепторы**:
- Auth: передача JWT между сервисами
- Logging: структурированное логирование вызовов
- Metrics: сбор метрик по вызовам
- Retry: повторные попытки при ошибках
- Circuit Breaker: защита от сбоев

---

### 2. Auth Service
**Назначение**: Мультитенантная аутентификация и авторизация с поддержкой JWT и API ключей

**Технологии**:
- gRPC сервер
- JWT токены (access: 15 мин, refresh: 7 дней)
- bcrypt для хеширования паролей (cost 10)
- PostgreSQL для хранения пользователей, тенантов, API ключей
- Redis для хранения сессий и rate limiting

**Порты**:
- gRPC: 50051
- Metrics: 9091 (Prometheus метрики)

**Методы**:
- `Register(email, password, tenantName)` - регистрация с созданием tenant
- `Login(email, password)` - аутентификация, генерация токенов
- `ValidateToken(token)` - валидация JWT токена
- `RefreshToken(refreshToken)` - обновление токенов
- `Logout(userID, tokenID)` - выход, отзыв токена
- `CreateAPIKey(tenantID, name, expiresAt)` - создание API ключа
- `ValidateAPIKey(key, secret)` - валидация API ключа
- `RevokeAPIKey(keyID)` - отзыв API ключа
- `ListAPIKeys(tenantID)` - список API ключей tenant

**Бизнес-правила**:
- Email уникален в рамках tenant
- Пароли: мин. 8 символов, проверка сложности
- API ключи: публичный key (UUID) + секретный secret (32 символа)
- Rate limiting: 10 запросов/мин на IP, 100 запросов/мин на пользователя

---

### 3. Config Service
**Назначение**: Управление конфигурациями проверок с мультитенантной поддержкой и валидацией

**Технологии**:
- gRPC сервер
- PostgreSQL для хранения конфигураций проверок
- Redis для кеширования конфигураций
- Валидаторы для каждого типа проверки

**Порты**:
- gRPC: 50052
- Metrics: 9092 (Prometheus метрики)

**Методы**:
- `CreateCheck(tenantID, check)` - создание проверки
- `GetCheck(checkID)` - получение проверки
- `UpdateCheck(checkID, check)` - обновление проверки
- `DeleteCheck(checkID)` - удаление проверки
- `ListChecks(tenantID, filter)` - список проверок с фильтрацией
- `ValidateCheckConfig(check)` - валидация конфигурации
- `ImportChecks(tenantID, checks)` - импорт проверок (JSON/YAML)
- `ExportChecks(tenantID, format)` - экспорт проверок

**Конфигурация проверки**:
```yaml
check:
  id: uuid
  tenant_id: uuid
  name: string
  type: http|grpc|graphql|tcp
  target: url|endpoint
  interval: seconds (min 5)
  timeout: seconds
  config:
    # HTTP
    method: GET|POST|PUT|DELETE
    headers: map[string]string
    body: string
    expected_status: int
    validation:
      json_path: string
      regex: string
    
    # gRPC
    service: string
    method: string
    proto_file: string|base64
    request_data: map[string]interface{}
    
    # GraphQL
    query: string
    variables: map[string]interface{}
    expected_data: map[string]interface{}
    
    # TCP
    port: int
    send_data: string
    expect_response: string
```

---

### 4. Scheduler Service
**Назначение**: Распределенный планировщик проверок с поддержкой cron выражений и приоритетов

**Технологии**:
- gRPC сервер
- Cron планировщик с поддержкой секундных интервалов
- RabbitMQ producer для отправки задач
- PostgreSQL для хранения расписаний и истории выполнения
- Redis для распределенных блокировок (Redlock алгоритм)

**Порты**:
- gRPC: 50053
- Metrics: 9093 (Prometheus метрики)

**Методы**:
- `ScheduleCheck(checkID, cronExpr, priority)` - планирование проверки
- `UnscheduleCheck(checkID)` - отмена планирования
- `GetSchedule(checkID)` - получение расписания
- `ListSchedules(tenantID)` - список расписаний
- `PauseCheck(checkID)` - пауза проверки
- `ResumeCheck(checkID)` - возобновление проверки
- `UpdateSchedule(checkID, cronExpr)` - обновление расписания
- `RunNow(checkID)` - немедленный запуск проверки
- `ListActiveJobs()` - список активных задач
- `GetJobHistory(checkID, limit)` - история выполнения

**Cron выражения**:
- Поддержка стандартных cron выражений (5 полей)
- Специальные значения: @every 5s, @hourly, @daily
- Минимальный интервал: 5 секунд

**Алгоритм выполнения**:
1. Загрузка активных расписаний при старте
2. Для каждого расписания создается cron задача
3. При срабатывании:
   4. Получение распределенной блокировки по check\_id
   5. Получение конфигурации из Config Service
   6. Отправка задачи в RabbitMQ очередь `check_tasks`
   7. Обновление last\_run и next\_run в БД
   8. Освобождение блокировки

---

### 5. Core Service (Worker)
**Назначение**: Основной сервис выполнения проверок мониторинга с поддержкой пула воркеров

**Технологии**:
- gRPC сервер
- HTTP/2 клиент для HTTP/HTTPS проверок
- gRPC клиент для gRPC проверок (с динамической загрузкой .proto)
- GraphQL клиент для GraphQL проверок
- TCP клиент для TCP проверок
- RabbitMQ consumer для получения задач
- Redis для кеширования результатов (TTL 5 минут)
- Worker pool для параллельного выполнения

**Порты**:
- gRPC: 50054
- Metrics: 9094 (Prometheus метрики)

**Методы**:
- `ExecuteCheck(check)` - выполнение проверки
- `GetCheckStatus(checkID)` - статус проверки
- `GetCheckHistory(checkID, limit, offset)` - история проверок
- `BatchExecuteChecks(checks)` - пакетное выполнение

**Типы проверок**:
- **HTTP/HTTPS**: GET, POST, PUT, DELETE, проверка статус кодов, валидация тела (JSON path, regex)
- **gRPC**: динамическая загрузка .proto, вызов методов, валидация ответов
- **GraphQL**: выполнение запросов, проверка данных, обработка ошибок GraphQL
- **TCP**: проверка подключения, таймауты

**Очереди RabbitMQ**:
- `check_tasks` - очередь для выполнения проверок (с DLQ)
- `check_results` - очередь для результатов
- `incident_events` - очередь для событий инцидентов

**Воркеры**:
- Конфигурируемый пул воркеров (по умолчанию: 10)
- Graceful shutdown: завершение текущих задач
- Retry логика с экспоненциальным backoff

---

### 6. Incident Manager
**Назначение**: Управление инцидентами мониторинга с дедупликацией и эскалацией

**Технологии**:
- gRPC сервер
- RabbitMQ consumer для получения результатов проверок
- RabbitMQ producer для отправки событий уведомлений
- PostgreSQL для хранения инцидентов и событий
- Алгоритмы дедупликации и группировки

**Порты**:
- gRPC: 50055
- Metrics: 9095 (Prometheus метрики)

**Методы**:
- `ProcessCheckResult(result)` - обработка результата проверки
- `CreateIncident(checkID, result)` - создание инцидента
- `UpdateIncident(incidentID, update)` - обновление инцидента
- `ResolveIncident(incidentID, resolution)` - разрешение инцидента
- `AcknowledgeIncident(incidentID, userID)` - подтверждение инцидента
- `GetIncident(incidentID)` - получение инцидента
- `ListIncidents(tenantID, filter)` - список инцидентов с фильтрацией
- `GetIncidentEvents(incidentID)` - события инцидента
- `GetOpenIncidents(tenantID)` - открытые инциденты

**Дедупликация**:
- Группировка по check\_id и хешу ошибки
- Алгоритм: SHA256(error\_message + status\_code + response\_body[:100]())
- Объединение повторных ошибок в один инцидент
- Автоматическое увеличение счетчика повторений

**Статусы инцидентов**:
- `open` - новый инцидент
- `acknowledged` - подтвержден оператором
- `resolved` - разрешен (проверка успешна)

**Severity уровни**:
- `warning` - незначительная проблема
- `error` - ошибка, требует внимания
- `critical` - критическая ошибка, немедленное действие

**Эскалация**:
- Автоматическое повышение severity при длительных инцидентах
- Уведомления об эскалации
- Назначение ответственных

---

### 7. Notification Service
**Назначение**: Мультиканальная система уведомлений с поддержкой шаблонов и rate limiting

**Технологии**:
- gRPC сервер
- RabbitMQ consumer для получения событий
- Поддержка провайдеров: Telegram, Slack, Email, Webhook
- PostgreSQL для хранения каналов и шаблонов
- Retry логика с экспоненциальным backoff

**Порты**:
- gRPC: 50056
- Metrics: 9096 (Prometheus метрики)

**Методы**:
- `SendNotification(tenantID, notification)` - отправка уведомления
- `SendBulkNotifications(notifications)` - массовая отправка
- `RegisterChannel(tenantID, channel)` - регистрация канала
- `UnregisterChannel(channelID)` - удаление канала
- `ListChannels(tenantID)` - список каналов
- `UpdateChannel(channelID, channel)` - обновление канала
- `CreateTemplate(tenantID, template)` - создание шаблона
- `UpdateTemplate(templateID, template)` - обновление шаблона
- `DeleteTemplate(templateID)` - удаление шаблона
- `ListTemplates(tenantID)` - список шаблонов

**Провайдеры**:

1. **Telegram**:
   2. Bot API интеграция
   3. Поддержка Markdown и HTML
   4. Кнопки действий (acknowledge, resolve)
   5. Rate limiting: 30 сообщений/секунду

2. **Slack**:
   2. Incoming Webhooks
   3. Блоки сообщений (blocks)
   4. Кнопки взаимодействия
   5. Эмодзи статусов

3. **Email**:
   2. SMTP отправка
   3. HTML шаблоны
   4. Вложения (отчеты)
   5. DKIM/SPF поддержка

4. **Webhook**:
   2. HTTP POST запросы
   3. Поддержка custom headers
   4. Retry логика
   5. Форматы: JSON, XML

**Шаблоны уведомлений**:
- Переменные: {{.CheckName}}, {{.Status}}, {{.Error}}, {{.Duration}}
- Условные блоки
- Форматирование для разных провайдеров

**Rate limiting**:
- Глобальные лимиты по провайдеру
- Лимиты на tenant
- Лимиты на канал
- Очередь отложенных уведомлений

---

### 8. Forge Service
**Назначение**: Инструмент для автоматической генерации конфигураций и кода проверок из .proto файлов

**Технологии**:
- gRPC сервер
- Парсинг .proto файлов (protobuf parser)
- Генерация Go кода для gRPC проверок
- PostgreSQL для хранения шаблонов и логов генерации
- Шаблоны (Go templates) для генерации

**Порты**:
- gRPC: 50057
- Metrics: 9097 (Prometheus метрики)

**Методы**:
- `ParseProto(protoContent)` - парсинг .proto файла
- `GenerateConfig(protoFile, options)` - генерация конфигурации проверок
- `GenerateCode(protoFile, options)` - генерация Go кода для проверок
- `GenerateTests(protoFile, options)` - генерация тестов
- `ValidateProto(protoContent)` - валидация .proto файла
- `SaveTemplate(tenantID, template)` - сохранение шаблона
- `GetTemplate(templateID)` - получение шаблона
- `ListTemplates(tenantID)` - список шаблонов
- `DeleteTemplate(templateID)` - удаление шаблона

**Генерация конфигурации**:
- Для каждого gRPC метода создается конфигурация проверки
- Автоматическое определение типов параметров
- Генерация тестовых данных
- Настройка интервалов и таймаутов
- Форматы вывода: YAML, JSON

**Генерация кода**:
- Go клиент для вызова gRPC методов
- Валидаторы ответов
- Интеграция с UptimePing Core
- Готовые шаблоны для разных фреймворков

**Интерактивная настройка**:
- Веб-интерфейс для настройки генерации
- Предпросмотр сгенерированного кода
- Экспорт в различные форматы
- Интеграция с CI/CD

---

### 9. Metrics Service
**Назначение**: Централизованный сбор, агрегация и экспорт метрик для мониторинга платформы

**Технологии**:
- HTTP сервер с /metrics endpoint
- Prometheus client library
- gRPC клиенты для сбора метрик из сервисов
- Redis для хранения временных рядов
- Агрегация и вычисление производных метрик

**Порты**:
- HTTP: 9090 (Prometheus metrics endpoint)
- Health: 9080 (health checks)

**Методы**:
- `/metrics` - экспорт метрик в формате Prometheus
- `/health` - health check сервиса
- `/ready` - readiness probe
- `/api/v1/metrics/query` - API для запроса метрик
- `/api/v1/metrics/alerts` - управление алертами

**Типы собираемых метрик**:

1. **Бизнес-метрики**:
   2. `uptime_checks_total{tenant, type, status}`
   3. `uptime_incidents_total{tenant, severity, status}`
   4. `uptime_notifications_sent_total{tenant, provider}`
   5. `uptime_users_active_total{tenant}`

2. **Технические метрики**:
   2. `uptime_service_requests_total{service, method, status}`
   3. `uptime_service_request_duration_seconds{service, method}`
   4. `uptime_service_errors_total{service, type}`
   5. `uptime_queue_messages_total{queue, status}`
   6. `uptime_db_connections_active{service}`
   7. `uptime_redis_connections_active{service}`

3. **Системные метрики**:
   2. `uptime_memory_usage_bytes{service}`
   3. `uptime_cpu_usage_percent{service}`
   4. `uptime_disk_usage_bytes{service}`
   5. `uptime_goroutines_total{service}`

**Агрегация**:
- Вычисление uptime по tenant и проверкам
- Расчет SLA/SLO показателей
- Агрегация по временным интервалам (1m, 5m, 15m, 1h, 1d)
- Вычисление процентилей (p50, p90, p95, p99)

**Алертинг**:
- Конфигурируемые алерты на основе метрик
- Уведомления при нарушении SLA
- Автоматическое создание инцидентов

---

### 10. CLI Service
**Назначение**: Командный интерфейс для управления платформой через терминал

**Технологии**:
- Cobra + Viper для CLI
- HTTP клиент для взаимодействия с API Gateway
- Конфигурационные файлы (YAML/JSON)
- Автодополнение (bash, zsh, fish)
- Цветной вывод и табличное форматирование

**Поддерживаемые платформы**:
- Linux (x86\_64, arm64)
- macOS (Intel, Apple Silicon)
- Windows (x86\_64)

**Основные команды**:

**Аутентификация**:
- `uptimeping auth login` - интерактивный вход
- `uptimeping auth logout` - выход
- `uptimeping auth api-key create` - создание API ключа
- `uptimeping auth api-key list` - список API ключей
- `uptimeping auth api-key revoke <id>` - отзыв API ключа

**Управление проверками**:
- `uptimeping config create` - создание новой проверки
- `uptimeping config get <id>` - получение конфигурации
- `uptimeping config update <id>` - обновление проверки
- `uptimeping config delete <id>` - удаление проверки
- `uptimeping config list` - список проверок с фильтрацией
- `uptimeping checks run <id>` - ручной запуск проверки
- `uptimeping checks status <id>` - статус проверки
- `uptimeping checks history <id>` - история выполнения

**Управление инцидентами**:
- `uptimeping incidents list` - список инцидентов с фильтрами
- `uptimeping incidents get <id>` - детали инцидента
- `uptimeping incidents acknowledge <id>` - подтверждение инцидента
- `uptimeping incidents resolve <id>` - разрешение инцидента

**Уведомления**:
- `uptimeping notification channels add` - добавление канала уведомлений
- `uptimeping notification channels list` - список каналов
- `uptimeping notification test` - тестовая отправка уведомления

**Forge интеграция**:
- `uptimeping forge generate --proto=path/to/file.proto` - генерация конфига из .proto
- `uptimeping forge validate --proto=path/to/file.proto` - валидация proto файла

**Продвинутые возможности**:
- Автодополнение команд для bash/zsh/fish
- Поддержка форматов вывода: JSON, YAML, таблица
- Контексты для переключения между окружениями
- Пакетирование: DEB/RPM для Linux, Homebrew для macOS, Chocolatey для Windows

## Коммуникация между сервисами

### Синхронная коммуникация (gRPC)

```
┌─────────────┐     gRPC     ┌─────────────┐
│ API Gateway ├─────────────►│ Auth Service│
└──────┬──────┘              └─────────────┘
       │     gRPC
       ├────────────────────► Config Service
       │     gRPC
       ├────────────────────► Scheduler Service
       │     gRPC
       ├────────────────────► Core Service
       │     gRPC
       ├────────────────────► Forge Service
       │     gRPC
       ├────────────────────► Incident Manager
       │     gRPC
       └────────────────────► Notification Service
```

### Асинхронная коммуникация (RabbitMQ)

```
┌────────────────┐      check_tasks      ┌─────────────┐
│ Scheduler      ├──────────────────────►│ Core        │
│ Service        │                       │ Service     │
└────────────────┘                       └──────┬──────┘
                                                │ check_results
┌────────────────┐                              ▼
│ Core           │      incident_events    ┌─────────────┐
│ Service        ├────────────────────────►│ Incident    │
└────────────────┘                         │ Manager     │
                                           └──────┬──────┘
                                                  │ notifications.send
┌────────────────┐                                ▼
│ Incident       │                         ┌─────────────┐
│ Manager        ├────────────────────────►│ Notification│
└────────────────┘                         │ Service     │
                                           └─────────────┘
```

### CLI Service взаимодействие

```
┌─────────────┐      HTTP/REST      ┌─────────────┐
│    CLI      ├────────────────────►│ API Gateway │
│   Service   │                     │   Service   │
└─────────────┘                     └─────────────┘
                                            │
                                            ▼ gRPC к внутренним сервисам
```

### Кеширование (Redis)
- **Результаты проверок**: TTL 5 минут, структура: `check_result:{check_id}:{timestamp}`
- **Конфигурации проверок**: TTL 1 минута, структура: `check_config:{check_id}`
- **Сессии и токены**: TTL 7 дней, структура: `session:{user_id}:{token_id}`
- **Распределенные блокировки**: TTL 30 секунд, структура: `lock:{resource}:{check_id}`
- **Rate limiting**: TTL 60 секунд, структура: `ratelimit:{type}:{key}`

### База данных (PostgreSQL)

**Auth Service**:
- `users(id, email, password_hash, tenant_id, is_active, created_at, updated_at)`
- `tenants(id, name, slug, settings, created_at, updated_at)`
- `api_keys(id, tenant_id, key_hash, secret_hash, name, is_active, expires_at, created_at)`
- `sessions(id, user_id, access_token_hash, refresh_token_hash, expires_at, created_at)`

**Config Service**:
- `checks(id, tenant_id, name, type, target, interval, timeout, config, status, created_at, updated_at)`
- `check_configs(id, check_id, version, config, created_at)`

**Scheduler Service**:
- `schedules(id, check_id, cron_expression, next_run, last_run, is_active, priority, created_at, updated_at)`
- `jobs(id, check_id, scheduled_time, executed_at, status, error, created_at)`
- `job_history(id, job_id, check_id, result, duration_ms, created_at)`

**Core Service**:
- `check_results(id, check_id, execution_id, success, duration_ms, status_code, error, response_body, checked_at)`
- `tasks(id, check_id, target, type, config, execution_id, scheduled_time, status, created_at)`

**Incident Manager**:
- `incidents(id, check_id, tenant_id, status, severity, first_seen, last_seen, count, error_message, error_hash, created_at, updated_at)`
- `incident_events(id, incident_id, type, data, created_at)`
- `incident_rules(id, tenant_id, name, conditions, actions, is_active, created_at)`

**Notification Service**:
- `notification_channels(id, tenant_id, type, config, is_active, created_at, updated_at)`
- `templates(id, tenant_id, name, type, content, variables, created_at, updated_at)`
- `notification_logs(id, channel_id, notification_id, status, error, sent_at, created_at)`

**Forge Service**:
- `proto_templates(id, tenant_id, name, proto_content, config_template, code_template, created_at, updated_at)`
- `generation_logs(id, tenant_id, template_id, result, generated_files, created_at)`

## Аутентификация и авторизация

### Мультитенантность
- Каждый пользователь принадлежит к tenant (организации)
- Tenant может иметь multiple пользователей
- Все данные изолированы по tenant\_id
- API ключи привязаны к tenant

### JWT Токены
- **Access Token**: 15 минут, содержит: `{user_id, email, tenant_id, roles, permissions}`
- **Refresh Token**: 7 дней, хранится в Redis, может быть отозван
- **Signature**: HMAC-SHA256 с секретным ключом
- **Валидация**: проверка подписи, срока действия, отзыва в Redis

### API Ключи
- **Key**: публичный идентификатор (UUID), хранится в БД
- **Secret**: приватный ключ (32 символа), показывается только при создании
- **Хеширование**: SHA256 для key и secret
- **Валидация**: сравнение хешей, проверка активности и срока действия

### Права доступа
- **Администратор tenant**: полный доступ ко всем ресурсам tenant
- **Оператор**: создание/управление проверками, просмотр инцидентов
- **Наблюдатель**: только просмотр
- **API пользователь**: ограниченный доступ через API ключи

### CLI Аутентификация
- Интерактивный логин через `uptimeping auth login`
- Сохранение токенов в защищенном хранилище (`~/.uptimeping/tokens`)
- Автоматическое обновление токенов
- Поддержка API ключей для CI/CD

## Инфраструктура

### Базы данных
- **PostgreSQL 14+**: основное хранилище данных, репликация, point-in-time recovery
- **Redis 7+**: кеширование, сессии, распределенные блокировки, pub/sub

### Очереди
- **RabbitMQ 3.11+**: асинхронная обработка задач, поддерживает DLQ, высокую доступность
- **Очереди с настройками**:
  - `check_tasks`: durable, подтверждения публикации, DLQ
  - `check_results`: durable, TTL сообщений
  - `incident_events`: durable, priority queues
  - `notifications.send`: durable, подтверждения потребления

### Мониторинг и логирование
- **Prometheus**: сбор метрик со всех сервисов
- **Grafana**: дашборды для метрик и логов
- **Loki**: сбор и агрегация логов
- **Promtail**: сбор логов из контейнеров
- **Alertmanager**: управление алертами

### Контейнеризация и оркестрация
- **Docker**: контейнеризация всех сервисов
- **Docker Compose**: локальная разработка и тестирование
- **Kubernetes**: продакшен деплой с Helm charts
- **Service mesh**: Istio/Linkerd для управления трафиком

### Безопасность
- **TLS/SSL**: все коммуникации шифруются
- **Secrets management**: HashiCorp Vault или Kubernetes Secrets
- **Network policies**: изоляция сетевого трафика
- **Audit logging**: логирование всех критических операций

### CI/CD
- **GitLab CI/CD**: автоматизация сборки, тестирования и деплоя
- **Этапы**:
  - `build`: сборка Docker образов и бинарников CLI
  - `test`: unit и интеграционные тесты
  - `scan`: security scanning (Trivy, Grype)
  - `package`: создание пакетов (DEB, RPM, Homebrew, Chocolatey)
  - `deploy:staging`: деплой в staging
  - `deploy:production`: деплой в production с approval
- **ArgoCD**: GitOps для управления деплоями в Kubernetes
- **GoReleaser**: автоматизация релизов CLI

## Масштабирование

### Горизонтальное масштабирование
- **Stateless сервисы**: API Gateway, Core Service (воркеры), CLI Service
- **Stateful сервисы**: требуется координация (Scheduler Service с распределенными блокировками)
- **Балансировка нагрузки**: round-robin, least-connections, sticky sessions

### Вертикальное масштабирование
- Настройка ресурсов (CPU, memory) в зависимости от нагрузки
- Мониторинг использования ресурсов
- Автоматическое scaling на основе метрик

### Репликация базы данных
- PostgreSQL: master-slave репликация для чтения
- Redis: Redis Cluster для распределенного кеширования
- RabbitMQ: mirrored queues для высокой доступности

## CLI Пакетирование и распространение

### Поддерживаемые форматы:
- **Linux**: DEB, RPM, tar.gz
- **macOS**: Homebrew formula, tar.gz
- **Windows**: Chocolatey package, zip
- **Docker**: контейнер с CLI

### Автоматизация релизов:
- **GoReleaser**: сборка и публикация релизов
- **GitHub Releases**: хостинг бинарников
- **Docker Hub**: образы Docker
- **Homebrew Tap**: установка через brew

### Документация CLI:
- Man pages
- Автогенерируемая помощь (`uptimeping --help`)
- Примеры использования
- Руководство по настройке

## Резервное копирование и восстановление

### Ежедневные бэкапы
- PostgreSQL: pg\_dump + WAL архивирование
- Redis: RDB snapshots + AOF
- Конфигурации: Git репозиторий
- CLI настройки: синхронизация с Git

### Восстановление
- Point-in-time recovery для PostgreSQL
- Восстановление из snapshots для Redis
- Процедуры аварийного восстановления
- Восстановление CLI конфигураций


