
## Общая информация

**Продолжительность**: 50 рабочих дней (10 недель)  
**Подход**: Итеративная разработка с детальной подготовительной фазой  
**Архитектура**: Clean Architecture с разделением на слои

## Микросервисы (10 сервисов)

1. **API Gateway** - единая точка входа, маршрутизация, аутентификация
2. **Auth Service** - аутентификация и авторизация (JWT, API Keys, Tenants)
3. **Config Service** - управление конфигурациями проверок (CRUD)
4. **Scheduler Service** - планировщик проверок (cron)
5. **Core Service** (Worker) - выполнение проверок (HTTP/gRPC/GraphQL)
6. **Incident Manager** - управление инцидентами, дедупликация
7. **Notification Service** - отправка уведомлений (Telegram, Slack, Email)
8. **Forge Service** - генерация конфигураций из .proto файлов
9. **Metrics Service** - сбор и экспорт метрик для Prometheus
10. **CLI Service** - командный интерфейс для управления платформой

---

## Часть 1: Подготовительная фаза (Дни 1-10)

### День 1-2: Инициализация проекта

#### Этап 1.1: Создание структуры monorepo (День 1, утро)
**Ветка**: `main`  
**Коммит**: `chore: initialize monorepo structure`

**Задачи**:
- Создать корневую директорию `uptimeping-platform`
- Инициализировать Git репозиторий
- Создать структуру директорий для всех сервисов
- Настроить `.gitignore` для Go, Docker, IDE
- Создать `README.md` с описанием проекта
- Настроить Go workspace: `go work init`

**Структура**:
```
uptimeping-platform/
├── .gitignore
├── README.md
├── go.work
├── services/
│   ├── api-gateway/
│   ├── auth-service/
│   ├── config-service/
│   ├── scheduler-service/
│   ├── core-service/
│   ├── incident-manager/
│   ├── notification-service/
│   ├── forge-service/
│   ├── metrics-service/
│   └── cli/                    
├── pkg/                    # Общие библиотеки
│   ├── config/
│   ├── logger/
│   ├── errors/
│   ├── database/
│   ├── redis/
│   └── rabbitmq/
├── proto/                   # gRPC контракты
│   └── api/
├── deployments/
│   ├── docker-compose/
│   └── k8s/
├── scripts/                 # Вспомогательные скрипты
├── docs/
└── tests/
    └── integration/
```

#### Этап 1.2: Настройка документации (День 1, вечер)
**Ветка**: `feature/docs-initial`  
**Коммит**: `docs: add initial project documentation`

**Задачи**:
- Создать `ARCHITECTURE.md` с описанием архитектуры
- Создать `CONTRIBUTING.md` с правилами разработки
- Создать `DEVELOPMENT.md` с инструкциями по запуску
- Создать `COMMIT_CONVENTIONS.md`
- Создать `BRANCH_STRATEGY.md`

#### Этап 1.3: Настройка CI/CD базовая (День 2, утро)
**Ветка**: `feature/cicd-basic`  
**Коммит**: `ci: add basic GitLab CI/CD configuration`

**Задачи**:
- Создать `.gitlab-ci.yml` с базовыми stages
- Настроить build stage для всех сервисов (включая CLI)
- Настроить test stage
- Добавить базовые job'ы
- Настроить сборку бинарников CLI для разных платформ

---

### День 3-4: Docker Compose инфраструктура

#### Этап 2.1: Основной docker-compose.yml (День 3, утро)
**Ветка**: `feature/infrastructure-docker-compose`  
**Коммит**: `feat(infra): add docker-compose for local development`

**Задачи**:
- Создать `deployments/docker-compose/docker-compose.yml`
- Определить сервисы: PostgreSQL, Redis, RabbitMQ
- Настроить health checks для каждого сервиса
- Определить volumes для сохранения данных
- Настроить networks (internal, external)
- Создать `.env.example` с переменными окружения

**Файлы**:
- `deployments/docker-compose/docker-compose.yml`
- `deployments/docker-compose/.env.example`

#### Этап 2.2: Настройка мониторинга (День 3, вечер)
**Ветка**: `feature/infrastructure-monitoring`  
**Коммит**: `feat(infra): add Prometheus, Grafana and Loki`

**Задачи**:
- Добавить Prometheus с конфигурацией сбора метрик
- Добавить Grafana с предустановленными дашбордами
- Добавить Loki для централизованного логирования
- Добавить Promtail для сбора логов
- Настроить интеграцию Grafana с Prometheus и Loki

**Файлы**:
- `deployments/docker-compose/prometheus/prometheus.yml`
- `deployments/docker-compose/grafana/provisioning/datasources.yml`
- `deployments/docker-compose/grafana/dashboards/`
- `deployments/docker-compose/loki/loki-config.yml`
- `deployments/docker-compose/promtail/promtail-config.yml`

#### Этап 2.3: Вспомогательные скрипты (День 4, утро)
**Ветка**: `feature/infrastructure-scripts`  
**Коммит**: `feat(infra): add helper scripts for development`

**Задачи**:
- Создать `scripts/wait-for-db.sh` - ожидание готовности БД
- Создать `scripts/init-db.sh` - инициализация базы данных
- Создать `scripts/setup-env.sh` - настройка переменных окружения
- Создать `scripts/migrate.sh` - запуск миграций
- Создать `Makefile` с командами для разработки

**Файлы**:
- `scripts/wait-for-db.sh`
- `scripts/init-db.sh`
- `scripts/setup-env.sh`
- `scripts/migrate.sh`
- `Makefile`

#### Этап 2.4: Тестирование инфраструктуры (День 4, вечер)
**Ветка**: `feature/infrastructure-testing`  
**Коммит**: `test(infra): verify docker-compose setup`

**Задачи**:
- Запустить docker-compose и проверить все сервисы
- Проверить health checks
- Проверить доступность портов
- Проверить volumes и networks
- Документировать процесс запуска

---

### День 5-6: Определение gRPC контрактов

#### Этап 3.1: Проектирование API (День 5, утро)
**Ветка**: `feature/proto-design`  
**Коммит**: `feat(proto): design gRPC API contracts`

**Задачи**:
- Создать структуру `proto/api/` с пакетами для каждого сервиса
- Определить package структуру: `uptimeping.{service}.v1`
- Спроектировать сервисы и методы для каждого микросервиса
- Определить структуры сообщений

**Структура proto**:
```
proto/api/
├── auth/
│   └── v1/
│       └── auth.proto
├── config/
│   └── v1/
│       └── config.proto
├── scheduler/
│   └── v1/
│       └── scheduler.proto
├── core/
│   └── v1/
│       └── core.proto
├── incident/
│   └── v1/
│       └── incident.proto
├── notification/
│   └── v1/
│       └── notification.proto
└── forge/
    └── v1/
        └── forge.proto
```

#### Этап 3.2: Создание контрактов Auth Service (День 5, вечер)
**Ветка**: `feature/proto-auth`  
**Коммит**: `feat(proto): add auth service contracts`

**Задачи**:
- Определить сервис `AuthService` с методами:
  - `Register` - регистрация пользователя
  - `Login` - вход пользователя
  - `ValidateToken` - валидация JWT токена
  - `RefreshToken` - обновление токена
  - `Logout` - выход
  - `CreateAPIKey` - создание API ключа
  - `ValidateAPIKey` - валидация API ключа
  - `RevokeAPIKey` - отзыв API ключа
- Определить сообщения: `User`, `TokenPair`, `APIKey`, `Tenant`

**Файлы**:
- `proto/api/auth/v1/auth.proto`

#### Этап 3.3: Создание контрактов остальных сервисов (День 6, утро)
**Ветка**: `feature/proto-all-services`  
**Коммит**: `feat(proto): add contracts for all services`

**Задачи**:
- Config Service: `CreateCheck`, `GetCheck`, `UpdateCheck`, `DeleteCheck`, `ListChecks`
- Scheduler Service: `ScheduleCheck`, `UnscheduleCheck`, `GetSchedule`, `ListSchedules`
- Core Service: `ExecuteCheck`, `GetCheckStatus`, `GetCheckHistory`
- Incident Manager: `CreateIncident`, `UpdateIncident`, `ResolveIncident`, `ListIncidents`
- Notification Service: `SendNotification`, `RegisterChannel`, `UnregisterChannel`
- Forge Service: `ParseProto`, `GenerateConfig`, `GenerateCode`, `ValidateProto`

**Файлы**:
- `proto/api/config/v1/config.proto`
- `proto/api/scheduler/v1/scheduler.proto`
- `proto/api/core/v1/core.proto`
- `proto/api/incident/v1/incident.proto`
- `proto/api/notification/v1/notification.proto`
- `proto/api/forge/v1/forge.proto`

#### Этап 3.4: Настройка генерации кода (День 6, вечер)
**Ветка**: `feature/proto-generation`  
**Коммит**: `feat(proto): setup code generation with buf`

**Задачи**:
- Установить `buf` для работы с proto файлами
- Создать `buf.yaml` и `buf.gen.yaml`
- Настроить генерацию Go кода
- Создать Makefile таргет `make proto` для генерации
- Проверить совместимость с protobuf версиями
- Добавить валидацию proto файлов

**Файлы**:
- `buf.yaml`
- `buf.gen.yaml`
- `Makefile` (обновить)

---

### День 7-9: Общие библиотеки

#### Этап 4.1: Система конфигурации (День 7, утро)
**Ветка**: `feature/pkg-config`  
**Коммит**: `feat(pkg): implement configuration system`

**Задачи**:
- Создать `pkg/config/config.go` с загрузкой из env и файлов
- Реализовать валидацию конфигурации
- Добавить поддержку разных окружений (dev, staging, prod)
- Поддержка вложенных структур
- Поддержка дефолтных значений
- Валидация обязательных полей

**Файлы**:
- `pkg/config/config.go`
- `pkg/config/config_test.go`

**Алгоритм LoadConfig()**:
1. Загрузка дефолтных значений
2. Загрузка из файла (если указан)
3. Переопределение из переменных окружения
4. Валидация конфигурации
5. Возврат конфигурации или ошибки

#### Этап 4.2: Логирование (День 7, вечер)
**Ветка**: `feature/pkg-logger`  
**Коммит**: `feat(pkg): implement structured logging`

**Задачи**:
- Настроить структурированное логирование с `zap`
- Добавить контекстное логирование с trace\_id
- Настроить интеграцию с Loki
- Добавить разные форматы (JSON для prod, console для dev)
- Добавить уровни логирования (debug, info, warn, error)

**Файлы**:
- `pkg/logger/logger.go`
- `pkg/logger/logger_test.go`

**Алгоритм NewLogger()**:
1. Определение формата (JSON/console) по окружению
2. Настройка уровней логирования
3. Настройка выходов (stdout, файл, Loki)
4. Создание zap logger
5. Возврат обертки с методами (Info, Error, etc.)

#### Этап 4.3: Обработка ошибок (День 8, утро)
**Ветка**: `feature/pkg-errors`  
**Коммит**: `feat(pkg): implement error handling system`

**Задачи**:
- Создать иерархию кастомных ошибок
- Реализовать middleware для обработки ошибок
- Добавить перевод ошибок для пользователя
- Интеграция с gRPC статусами
- Интеграция с HTTP статусами

**Файлы**:
- `pkg/errors/errors.go`
- `pkg/errors/errors_test.go`

**Типы ошибок**:
- `ErrNotFound` - ресурс не найден
- `ErrValidation` - ошибка валидации
- `ErrUnauthorized` - не авторизован
- `ErrForbidden` - доступ запрещен
- `ErrInternal` - внутренняя ошибка
- `ErrConflict` - конфликт (например, дубликат)

#### Этап 4.4: Метрики и телеметрия (День 8, вечер)
**Ветка**: `feature/pkg-metrics`  
**Коммит**: `feat(pkg): implement metrics and telemetry`

**Задачи**:
- Настроить Prometheus метрики
- Добавить OpenTelemetry для трассировки (опционально)
- Создать health check эндпоинты
- Стандартные метрики: request duration, request count, errors

**Файлы**:
- `pkg/metrics/metrics.go`
- `pkg/health/health.go`

#### Этап 4.5: Database и Redis утилиты (День 9, утро)
**Ветка**: `feature/pkg-database`  
**Коммит**: `feat(pkg): add database and redis utilities`

**Задачи**:
- Создать `pkg/database/postgres.go` - подключение к PostgreSQL
- Создать `pkg/redis/client.go` - подключение к Redis
- Реализовать connection pooling
- Реализовать retry логику
- Health checks для подключений

**Файлы**:
- `pkg/database/postgres.go`
- `pkg/redis/client.go`

#### Этап 4.6: RabbitMQ утилиты (День 9, вечер)
**Ветка**: `feature/pkg-rabbitmq`  
**Коммит**: `feat(pkg): add RabbitMQ utilities`

**Задачи**:
- Создать `pkg/rabbitmq/connection.go` - подключение к RabbitMQ
- Реализовать producer с подтверждениями
- Реализовать consumer с обработкой ошибок
- Поддержка DLQ (Dead Letter Queue)
- Retry логика

**Файлы**:
- `pkg/rabbitmq/connection.go`
- `pkg/rabbitmq/producer.go`
- `pkg/rabbitmq/consumer.go`

---

### День 10: База данных и миграции

#### Этап 5.1: Проектирование схемы БД (День 10, утро)
**Ветка**: `feature/db-schema-design`  
**Коммит**: `feat(db): design database schema`

**Задачи**:
- Создать ER-диаграмму всех таблиц
- Определить связи между таблицами
- Настроить индексы для частых запросов
- Определить constraints и foreign keys

**Таблицы**:
- `users` - пользователи
- `tenants` - организации (мультитенантность)
- `api_keys` - API ключи
- `sessions` - сессии (JWT refresh tokens)
- `checks` - конфигурации проверок
- `schedules` - расписания проверок
- `check_results` - результаты проверок
- `incidents` - инциденты
- `incident_events` - события инцидентов
- `notification_channels` - каналы уведомлений
- `proto_templates` - шаблоны .proto файлов

#### Этап 5.2: Создание миграций (День 10, вечер)
**Ветка**: `feature/db-migrations`  
**Коммит**: `feat(db): create initial database migrations`

**Задачи**:
- Настроить Goose для управления миграциями
- Создать начальные миграции для всех таблиц
- Добавить индексы
- Добавить seed данные для разработки
- Создать скрипт для применения миграций

**Файлы**:
- `migrations/001_create_users.sql`
- `migrations/002_create_tenants.sql`
- `migrations/003_create_api_keys.sql`
- `migrations/004_create_sessions.sql`
- `migrations/005_create_checks.sql`
- `migrations/006_create_schedules.sql`
- `migrations/007_create_check_results.sql`
- `migrations/008_create_incidents.sql`
- `migrations/009_create_incident_events.sql`
- `migrations/010_create_notification_channels.sql`
- `migrations/011_create_proto_templates.sql`
- `migrations/seed/001_seed_dev_data.sql`

---

## Часть 2: Сервис Gateway и аутентификация (Дни 11-20)

### День 11-13: Доменная модель аутентификации

#### Этап 6.1: Проектирование сущностей (День 11)
**Ветка**: `feature/auth-domain-models`  
**Коммит**: `feat(auth): design domain models`

**Задачи**:
- Создать `auth-service/internal/domain/models.go`
- Определить сущности:
  - `User`: id, email, password\_hash, tenant\_id, is\_active, is\_admin, created\_at, updated\_at
  - `Tenant`: id, name, slug, settings, created\_at, updated\_at
  - `APIKey`: id, tenant\_id, key\_hash, secret\_hash, name, is\_active, expires\_at, created\_at
  - `Session`: id, user\_id, access\_token\_hash, refresh\_token\_hash, expires\_at, created\_at

**Бизнес-правила**:
- Пароли хранятся с использованием bcrypt (cost 10)
- JWT токены: access (15 мин), refresh (7 дней)
- Refresh токены хранятся в Redis для возможности отзыва
- API ключи: key (публичный, в БД), secret (приватный, только при создании)
- Email должен быть уникальным в рамках tenant

#### Этап 6.2: Репозитории (День 12, утро)
**Ветка**: `feature/auth-repositories`  
**Коммит**: `feat(auth): implement repositories`

**Задачи**:
- Создать интерфейсы репозиториев
- Реализовать UserRepository (PostgreSQL)
- Реализовать TenantRepository (PostgreSQL)
- Реализовать APIKeyRepository (PostgreSQL)
- Реализовать SessionRepository (Redis)
- Написать unit тесты

**Файлы**:
- `auth-service/internal/repository/interfaces.go`
- `auth-service/internal/repository/postgres/user_repository.go`
- `auth-service/internal/repository/postgres/tenant_repository.go`
- `auth-service/internal/repository/postgres/api_key_repository.go`
- `auth-service/internal/repository/redis/session_repository.go`

#### Этап 6.3: JWT и Password утилиты (День 12, вечер)
**Ветка**: `feature/auth-utils`  
**Коммит**: `feat(auth): add JWT and password utilities`

**Задачи**:
- Реализовать JWT генерацию и валидацию
- Реализовать хеширование паролей (bcrypt)
- Реализовать хеширование API ключей
- Написать тесты

**Файлы**:
- `auth-service/internal/pkg/jwt/jwt.go`
- `auth-service/internal/pkg/password/password.go`
- `auth-service/internal/pkg/apikey/apikey.go`

### День 14-16: Use Cases аутентификации

#### Этап 7.1: Login Use Case (День 14, утро)
**Ветка**: `feature/auth-login-usecase`  
**Коммит**: `feat(auth): implement login use case`

**Задачи**:
- Реализовать `Login(email, password) (*TokenPair, error)`
- Валидация email и password
- Поиск пользователя по email
- Проверка пароля (bcrypt.CompareHashAndPassword)
- Генерация JWT токенов
- Сохранение refresh токена в Redis
- Возврат токенов

**Файлы**:
- `auth-service/internal/service/auth_service.go`

**Алгоритм Login()**:
1. Валидация входных данных (email формат, password не пустой)
2. Поиск пользователя по email в БД
3. Если не найден → возврат ErrNotFound
4. Проверка is\_active → если false → ErrForbidden
5. Проверка пароля (bcrypt.CompareHashAndPassword)
6. Если неверный → возврат ErrUnauthorized
7. Генерация access токена (15 мин, содержит user\_id, email, tenant\_id)
8. Генерация refresh токена (7 дней)
9. Сохранение refresh токена в Redis (TTL 7 дней, ключ: `refresh_token:{hash}`)
10. Возврат TokenPair

#### Этап 7.2: Register и Token Use Cases (День 14, вечер)
**Ветка**: `feature/auth-register-token-usecases`  
**Коммит**: `feat(auth): implement register and token use cases`

**Задачи**:
- Реализовать `Register(email, password, tenantName) (*TokenPair, error)`
- Реализовать `RefreshToken(refreshToken string) (*TokenPair, error)`
- Реализовать `Logout(userID, tokenID string) error`
- Написать тесты

**Алгоритм Register()**:
1. Валидация email и password
2. Проверка существования пользователя по email
3. Если существует → ErrConflict
4. Создание или получение tenant по имени
5. Хеширование пароля (bcrypt)
6. Создание пользователя в БД
7. Генерация токенов (как в Login)
8. Сохранение refresh токена в Redis
9. Возврат токенов

**Алгоритм RefreshToken()**:
1. Парсинг refresh токена
2. Проверка подписи и срока действия
3. Поиск токена в Redis
4. Если не найден → ErrUnauthorized (токен отозван)
5. Удаление старого refresh токена из Redis
6. Генерация новой пары токенов
7. Сохранение нового refresh токена в Redis
8. Возврат новых токенов

#### Этап 7.3: API Key Use Cases (День 15)
**Ветка**: `feature/auth-apikey-usecases`  
**Коммит**: `feat(auth): implement API key use cases`

**Задачи**:
- Реализовать `CreateAPIKey(tenantID, name string) (*APIKeyPair, error)`
- Реализовать `ValidateAPIKey(key, secret string) (*Claims, error)`
- Реализовать `RevokeAPIKey(keyID string) error`
- Написать тесты

**Алгоритм CreateAPIKey()**:
1. Генерация key (публичный идентификатор, UUID)
2. Генерация secret (случайная строка, 32 символа)
3. Хеширование key и secret (SHA256)
4. Сохранение в БД (key\_hash, secret\_hash, name, tenant\_id)
5. Возврат APIKeyPair (key, secret) - secret показывается только один раз

**Алгоритм ValidateAPIKey()**:
1. Хеширование key и secret
2. Поиск в БД по key\_hash
3. Если не найден → ErrUnauthorized
4. Проверка is\_active → если false → ErrForbidden
5. Проверка expires\_at → если истек → ErrUnauthorized
6. Сравнение secret\_hash
7. Если не совпадает → ErrUnauthorized
8. Возврат Claims (tenant\_id, key\_id)

#### Этап 7.4: Rate Limiting (День 16)
**Ветка**: `feature/auth-rate-limiting`  
**Коммит**: `feat(auth): implement rate limiting`

**Задачи**:
- Настроить лимиты по IP адресу (Redis)
- Настроить лимиты по пользователю (Redis)
- Реализовать sliding window алгоритм
- Интеграция с middleware

**Файлы**:
- `pkg/ratelimit/ratelimit.go`

**Алгоритм CheckRateLimit()**:
1. Определение ключа (IP или user\_id)
2. Получение текущего счетчика из Redis
3. Если счетчик \>= лимит → ErrTooManyRequests
4. Увеличение счетчика (INCR)
5. Установка TTL для ключа
6. Возврат успеха

### День 17-18: HTTP интерфейс Gateway

#### Этап 8.1: Маршрутизация (День 17, утро)
**Ветка**: `feature/gateway-routing`  
**Коммит**: `feat(gateway): implement HTTP routing`

**Задачи**:
- Настроить роутинг с использованием gin или chi
- Публичные роуты: `/api/v1/auth/login`, `/api/v1/auth/register`
- Защищенные роуты: `/api/v1/*` (требуют аутентификации)
- Прокси роуты: `/api/v1/checks` → Scheduler Service
- Health check: `/health`

**Файлы**:
- `api-gateway/internal/handler/http/handler.go`
- `api-gateway/internal/handler/http/auth.go`
- `api-gateway/internal/handler/http/checks.go`
- `api-gateway/internal/handler/http/scheduler.go`
- `api-gateway/internal/handler/http/forge.go`

#### Этап 8.2: Middleware цепочка (День 17, вечер)
**Ветка**: `feature/gateway-middleware`  
**Коммит**: `feat(gateway): implement middleware chain`

**Задачи**:
- CORS middleware: настройка разрешенных источников
- Logging middleware: логирование всех запросов с trace\_id
- Recovery middleware: обработка паник
- Auth middleware: проверка JWT токена или API ключа
- Rate Limit middleware: проверка лимитов запросов

**Файлы**:
- `api-gateway/internal/middleware/cors.go`
- `api-gateway/internal/middleware/logging.go`
- `api-gateway/internal/middleware/recovery.go`
- `api-gateway/internal/middleware/auth.go`
- `api-gateway/internal/middleware/rate_limit.go`

**Алгоритм AuthMiddleware()**:
1. Проверка наличия заголовка Authorization
2. Определение типа аутентификации (Bearer или APIKey)
3. Если Bearer:
   4. Извлечение токена
   5. Вызов Auth Service: ValidateToken()
   6. Добавление user\_id, tenant\_id в контекст
4. Если APIKey:
   8. Извлечение key и secret
   9. Вызов Auth Service: ValidateAPIKey()
   10. Добавление tenant\_id в контекст
5. Если не авторизован → возврат 401
6. Продолжение выполнения

#### Этап 8.3: Обработчики запросов (День 18)
**Ветка**: `feature/gateway-handlers`  
**Коммит**: `feat(gateway): implement HTTP handlers`

**Задачи**:
- Auth handlers: Login, Register, RefreshToken, Logout
- Health handlers: HealthCheck
- Proxy handlers: маршрутизация к другим сервисам через gRPC
- Обработка ошибок и преобразование в HTTP статусы

**Файлы**:
- `api-gateway/internal/handler/http/auth.go` (обновить)
- `api-gateway/internal/handler/http/health.go`

### День 19-20: gRPC клиенты и интерцепторы

#### Этап 9.1: Клиенты к другим сервисам (День 19, утро)
**Ветка**: `feature/gateway-grpc-clients`  
**Коммит**: `feat(gateway): implement gRPC clients`

**Задачи**:
- Реализовать клиенты для всех сервисов
- Connection pooling
- Retry логика
- Timeout настройки

**Файлы**:
- `api-gateway/internal/client/auth_client.go`
- `api-gateway/internal/client/config_client.go`
- `api-gateway/internal/client/scheduler_client.go`
- `api-gateway/internal/client/core_client.go`
- `api-gateway/internal/client/incident_client.go`
- `api-gateway/internal/client/forge_client.go`

#### Этап 9.2: gRPC интерцепторы (День 19, вечер)
**Ветка**: `feature/gateway-grpc-interceptors`  
**Коммит**: `feat(gateway): implement gRPC interceptors`

**Задачи**:
- Auth Interceptor: передача JWT токена между сервисами
- Logging Interceptor: логирование gRPC вызовов
- Metrics Interceptor: сбор метрик по вызовам
- Retry Interceptor: повторные попытки при ошибках
- Circuit Breaker: обработка сбоев

**Файлы**:
- `api-gateway/internal/interceptor/auth.go`
- `api-gateway/internal/interceptor/logging.go`
- `api-gateway/internal/interceptor/metrics.go`
- `api-gateway/internal/interceptor/retry.go`
- `api-gateway/internal/interceptor/circuit_breaker.go`

#### Этап 9.3: Балансировка нагрузки (День 20)
**Ветка**: `feature/gateway-load-balancing`  
**Коммит**: `feat(gateway): implement client-side load balancing`

**Задачи**:
- Настройка client-side load balancing
- Health checking для определения доступных инстансов
- Round-robin и least-connections стратегии
- Интеграция с service discovery (если используется)

---

## Часть 3: Сервис Scheduler (Дни 21-28)

### День 21-22: Доменная модель планировщика

#### Этап 10.1: Сущность Check (День 21)
**Ветка**: `feature/scheduler-domain-models`  
**Коммит**: `feat(scheduler): design domain models`

**Задачи**:
- Создать `scheduler-service/internal/domain/models.go`
- Определить сущность `Check`:
  - Основные поля: id, tenant\_id, name, type, target, interval, timeout, status
  - Конфигурация: специфичная для типа проверки (JSON)
  - Статусы: active, paused, disabled
- Определить типы проверок: HTTP/HTTPS, gRPC, GraphQL, TCP

**Файлы**:
- `scheduler-service/internal/domain/models.go`

#### Этап 10.2: Расписание (День 22, утро)
**Ветка**: `feature/scheduler-schedule-model`  
**Коммит**: `feat(scheduler): add schedule domain model`

**Задачи**:
- Определить сущность `Schedule`:
  - check\_id, cron\_expression, next\_run, last\_run, is\_active
- Интервалы: от 5 секунд до 24 часов
- Cron выражения: для сложного расписания
- Приоритеты: важные проверки выполняются первыми

### День 23-24: Use Cases планировщика

#### Этап 11.1: Управление проверками (День 23)
**Ветка**: `feature/scheduler-check-usecases`  
**Коммит**: `feat(scheduler): implement check management use cases`

**Задачи**:
- Реализовать `CreateCheck(tenantID, check *Check) (*Check, error)`
- Реализовать `UpdateCheck(checkID string, check *Check) error`
- Реализовать `DeleteCheck(checkID string) error`
- Валидация конфигурации проверки

**Алгоритм CreateCheck()**:
1. Валидация конфигурации проверки
2. Установка tenant\_id
3. Генерация check\_id (UUID)
4. Сохранение в БД
5. Если status = active → добавление в планировщик
6. Возврат созданной проверки

#### Этап 11.2: Выполнение расписания (День 24, утро)
**Ветка**: `feature/scheduler-execution`  
**Коммит**: `feat(scheduler): implement schedule execution`

**Задачи**:
- Загрузка активных проверок при старте
- Создание cron задач для каждой проверки
- При срабатывании таймера → создание задачи в RabbitMQ
- Обновление next\_run и last\_run

**Алгоритм выполнения cron задачи**:
1. Получение распределенной блокировки (Redis) по check\_id
2. Если блокировка получена:
   3. Получение конфигурации проверки из БД
   4. Создание задачи (check\_id, scheduled\_time, priority)
   5. Отправка задачи в RabbitMQ очередь `check_tasks`
   6. Обновление last\_run и next\_run в БД
3. Освобождение блокировки

### День 25-26: Интеграция с очередями

#### Этап 12.1: Настройка RabbitMQ (День 25, утро)
**Ветка**: `feature/scheduler-rabbitmq-setup`  
**Коммит**: `feat(scheduler): setup RabbitMQ exchanges and queues`

**Задачи**:
- Создание exchange: `uptimeping.events` (topic)
- Создание queue: `check_tasks` с DLQ
- Настройка routing keys: `check.execute.{check_id}`
- Настройка publisher confirms

**Файлы**:
- `scheduler-service/internal/rabbitmq/setup.go`

#### Этап 12.2: Публикация событий (День 25, вечер)
**Ветка**: `feature/scheduler-rabbitmq-producer`  
**Коммит**: `feat(scheduler): implement RabbitMQ producer`

**Задачи**:
- Сериализация задачи в JSON
- Добавление headers для маршрутизации
- Подтверждение публикации (publisher confirms)
- Retry при недоступности RabbitMQ

**Файлы**:
- `scheduler-service/internal/producer/rabbitmq/producer.go`

#### Этап 12.3: Обработка ошибок (День 26)
**Ветка**: `feature/scheduler-error-handling`  
**Коммит**: `feat(scheduler): implement error handling for queue`

**Задачи**:
- Retry при недоступности RabbitMQ
- Сохранение неудачных задач в БД
- Уведомление администратора о проблемах
- Dead letter queue обработка

### День 27-28: gRPC сервер Scheduler

#### Этап 13.1: Реализация методов (День 27)
**Ветка**: `feature/scheduler-grpc-handlers`  
**Коммит**: `feat(scheduler): implement gRPC handlers`

**Задачи**:
- CreateCheck: создание и планирование проверки
- UpdateCheck: обновление и перепланирование
- DeleteCheck: удаление и отмена планирования
- ListChecks: пагинация, фильтрация, сортировка
- GetSchedule: получение расписания проверки
- HealthCheck: проверка состояния сервиса

**Файлы**:
- `scheduler-service/internal/handler/grpc/handler.go`

#### Этап 13.2: Валидация и обработка ошибок (День 28)
**Ветка**: `feature/scheduler-validation`  
**Коммит**: `feat(scheduler): add request validation and error handling`

**Задачи**:
- Проверка обязательных полей
- Валидация формата target (URL, gRPC endpoint)
- Проверка корректности интервалов (min 5 секунд)
- Конвертация доменных ошибок в gRPC статусы
- Логирование ошибок с контекстом

---

## Часть 4: Сервис Core (Worker) (Дни 29-36)

### День 29-30: Доменная модель исполнителя

#### Этап 14.1: Сущность Task и Result (День 29)
**Ветка**: `feature/core-domain-models`  
**Коммит**: `feat(core): design domain models`

**Задачи**:
- Создать `core-service/internal/domain/models.go`
- Определить сущность `Task`:
  - check\_id, target, type, config, execution\_id, scheduled\_time
- Определить сущность `CheckResult`:
  - check\_id, execution\_id, success, duration\_ms, status\_code, error, response\_body, checked\_at

**Файлы**:
- `core-service/internal/domain/models.go`

#### Этап 14.2: Типы исполнителей (День 30, утро)
**Ветка**: `feature/core-checkers`  
**Коммит**: `feat(core): define checker interfaces`

**Задачи**:
- Определить интерфейс `Checker`:
```go
type Checker interface {
    Execute(check *Check) (*CheckResult, error)
}
```
- Определить типы: HTTPChecker, gRPCChecker, GraphQLChecker, TCPChecker

**Файлы**:
- `core-service/internal/service/checker/interface.go`

### День 31-32: Use Cases Worker

#### Этап 15.1: HTTP Checker (День 31, утро)
**Ветка**: `feature/core-http-checker`  
**Коммит**: `feat(core): implement HTTP checker`

**Задачи**:
- Реализовать HTTPChecker
- Поддержка GET, POST, PUT, DELETE
- Проверка статус кодов
- Проверка тела ответа (JSON path, regex)
- Измерение времени ответа
- Настройка таймаутов

**Файлы**:
- `core-service/internal/service/checker/http_checker.go`

**Алгоритм Execute()**:
1. Создание HTTP клиента с таймаутом из конфигурации
2. Формирование запроса (method, headers, body)
3. Выполнение запроса с измерением времени
4. Проверка статус кода (ожидаемый vs фактический)
5. Если указана валидация тела → проверка (JSON path, regex)
6. Формирование результата (success, status\_code, response\_time\_ms, error)
7. Возврат результата

#### Этап 15.2: gRPC и GraphQL Checkers (День 31, вечер)
**Ветка**: `feature/core-grpc-graphql-checkers`  
**Коммит**: `feat(core): implement gRPC and GraphQL checkers`

**Задачи**:
- Реализовать gRPCChecker
- Реализовать GraphQLChecker
- Написать тесты

**Файлы**:
- `core-service/internal/service/checker/grpc_checker.go`
- `core-service/internal/service/checker/graphql_checker.go`

#### Этап 15.3: Обработка задач (День 32)
**Ветка**: `feature/core-task-processing`  
**Коммит**: `feat(core): implement task processing`

**Задачи**:
- Получение задачи из RabbitMQ
- Определение типа проверки
- Вызов соответствующего checker'а
- Запись результата в БД
- Отправка результата в Incident Manager

**Файлы**:
- `core-service/internal/service/check_service.go`
- `core-service/internal/consumer/rabbitmq/consumer.go`

**Алгоритм ProcessTask()**:
1. Десериализация сообщения из RabbitMQ
2. Получение конфигурации проверки из Config Service
3. Определение типа проверки
4. Вызов соответствующего checker'а
5. Сохранение результата в БД
6. Если проверка неудачна → отправка в Incident Manager
7. Кеширование результата в Redis (TTL 5 минут)
8. ACK сообщения

### День 33-34: Интеграция с другими сервисами

#### Этап 16.1: Отправка результатов (День 33, утро)
**Ветка**: `feature/core-incident-integration`  
**Коммит**: `feat(core): integrate with incident manager`

**Задачи**:
- gRPC вызов к Incident Manager
- Передача данных о проверке и результате
- Обработка ошибок при отправке
- Retry логика

**Файлы**:
- `core-service/internal/client/incident_client.go`

#### Этап 16.2: Сбор метрик (День 33, вечер)
**Ветка**: `feature/core-metrics`  
**Коммит**: `feat(core): add Prometheus metrics`

**Задачи**:
- Экспорт метрик в Prometheus
- Метрики: `uptime_check_duration_seconds`, `uptime_check_total`
- Лейблы: type, target, status

**Файлы**:
- `core-service/internal/metrics/metrics.go`

#### Этап 16.3: Логирование (День 34, утро)
**Ветка**: `feature/core-logging`  
**Коммит**: `feat(core): improve structured logging`

**Задачи**:
- Структурированные логи с trace\_id
- Разные уровни логирования: debug, info, error
- Контекст выполнения: check\_id, execution\_id

### День 35-36: Конфигурация и запуск

#### Этап 17.1: Конфигурация пула воркеров (День 35)
**Ветка**: `feature/core-worker-pool`  
**Коммит**: `feat(core): implement worker pool configuration`

**Задачи**:
- Количество одновременных проверок
- Таймауты для разных типов проверок
- Настройки повторных попыток
- Graceful shutdown

**Файлы**:
- `core-service/internal/worker/pool.go`

#### Этап 17.2: Health checks и запуск (День 36)
**Ветка**: `feature/core-health-startup`  
**Коммит**: `feat(core): add health checks and startup logic`

**Задачи**:
- Проверка подключения к RabbitMQ
- Проверка подключения к БД
- Проверка доступности Incident Manager
- Graceful shutdown: завершение текущих проверок, возврат незавершенных задач в очередь

**Файлы**:
- `core-service/internal/health/health.go`
- `core-service/cmd/server/main.go` (обновить)

---

## Часть 5: Сервис Incident Manager (Дни 37-42)

### День 37-38: Доменная модель инцидентов

#### Этап 18.1: Сущность Incident (День 37)
**Ветка**: `feature/incident-domain-models`  
**Коммит**: `feat(incident): design domain models`

**Задачи**:
- Создать `incident-manager/internal/domain/models.go`
- Определить сущность `Incident`:
  - id, check\_id, tenant\_id, status, severity, first\_seen, last\_seen, count
  - error\_message, error\_hash (для дедупликации)
- Определить статусы: open, acknowledged, resolved
- Определить severity: warning, error, critical

**Файлы**:
- `incident-manager/internal/domain/models.go`

#### Этап 18.2: Политики инцидентов (День 38, утро)
**Ветка**: `feature/incident-policies`  
**Коммит**: `feat(incident): define incident policies`

**Задачи**:
- Политика создания: при первой ошибке проверки
- Дедупликация: объединение повторных ошибок по check\_id и error\_hash
- Разрешение: при успешной проверке после ошибки
- Эскалация: автоматическое повышение severity при длительных инцидентах

### День 39-40: Use Cases Incident Manager

#### Этап 19.1: Обработка результатов проверок (День 39, утро)
**Ветка**: `feature/incident-processing`  
**Коммит**: `feat(incident): implement check result processing`

**Задачи**:
- Реализовать `ProcessCheckResult(result *CheckResult) error`
- Определение: успех или ошибка
- Применение политик создания/обновления инцидентов

**Алгоритм ProcessCheckResult()**:
1. Если проверка успешна:
   2. Поиск открытого инцидента по check\_id
   3. Если найден → закрытие инцидента (status = resolved)
   4. Публикация события `incident.resolved`
2. Если проверка неудачна:
   6. Вычисление error\_hash (SHA256 от error\_message)
   7. Поиск открытого инцидента по check\_id и error\_hash
   8. Если найден:
	 - Обновление: count++, last\_seen = now
	 - Публикация события `incident.updated`
   9. Если не найден:
	 - Создание нового инцидента
	 - Определение severity (по типу ошибки)
	 - Публикация события `incident.opened`

#### Этап 19.2: Дедупликация (День 39, вечер)
**Ветка**: `feature/incident-deduplication`  
**Коммит**: `feat(incident): implement incident deduplication`

**Задачи**:
- Проверка существующих открытых инцидентов
- Объединение по check\_id и error\_hash
- Обновление счетчика и времени последнего появления
- Логика группировки похожих ошибок

#### Этап 19.3: Управление жизненным циклом (День 40)
**Ветка**: `feature/incident-lifecycle`  
**Коммит**: `feat(incident): implement incident lifecycle management`

**Задачи**:
- Открытие инцидента при первой ошибке
- Обновление при повторных ошибках
- Закрытие при успешной проверке
- Эскалация при длительных инцидентах

### День 41-42: Интеграция с очередями

#### Этап 20.1: Публикация событий (День 41)
**Ветка**: `feature/incident-events`  
**Коммит**: `feat(incident): implement event publishing`

**Задачи**:
- При открытии инцидента: `incident.opened`
- При обновлении: `incident.updated`
- При закрытии: `incident.resolved`
- Формат событий с обязательными и опциональными полями

**Файлы**:
- `incident-manager/internal/producer/rabbitmq/producer.go`

#### Этап 20.2: gRPC сервер (День 42)
**Ветка**: `feature/incident-grpc`  
**Коммит**: `feat(incident): implement gRPC server`

**Задачи**:
- CreateIncident, UpdateIncident, ResolveIncident
- ListIncidents: пагинация, фильтрация, сортировка
- GetIncident: получение инцидента с историей
- HealthCheck

**Файлы**:
- `incident-manager/internal/handler/grpc/handler.go`

---

## Часть 6: Сервисы Notifier, Forge и Metrics (Дни 43-48)

### День 43: Сервис Notifier

#### Этап 21.1: Подписка на события (День 43, утро)
**Ветка**: `feature/notification-consumer`  
**Коммит**: `feat(notification): implement RabbitMQ consumer`

**Задачи**:
- Consumer RabbitMQ очереди `notifications`
- Фильтрация событий по типу и severity
- Группировка уведомлений

**Файлы**:
- `notification-service/internal/consumer/rabbitmq/consumer.go`

#### Этап 21.2: Отправка уведомлений (День 43, вечер)
**Ветка**: `feature/notification-senders`  
**Коммит**: `feat(notification): implement notification senders`

**Задачи**:
- Telegram: форматирование сообщения, отправка через Bot API
- Slack: отправка в каналы, форматирование blocks
- Email: шаблоны писем, отправка через SMTP
- Retry логика с экспоненциальной backoff

**Файлы**:
- `notification-service/internal/provider/telegram/telegram.go`
- `notification-service/internal/provider/slack/slack.go`
- `notification-service/internal/provider/email/email.go`

### День 44: Forge Service

#### Этап 22.1: Парсинг .proto файлов (День 44, утро)
**Ветка**: `feature/forge-parser`  
**Коммит**: `feat(forge): implement proto file parser`

**Задачи**:
- Загрузка и валидация proto файлов
- Парсинг сервисов и методов
- Извлечение типов сообщений

**Файлы**:
- `forge-service/internal/service/proto_parser.go`

#### Этап 22.2: Генерация конфигураций (День 44, вечер)
**Ветка**: `feature/forge-generator`  
**Коммит**: `feat(forge): implement config and code generation`

**Задачи**:
- Генерация YAML конфига для UptimePing Core
- Генерация Go кода для проверки gRPC методов
- Интерактивная настройка (Telegram bot token, chat\_id)

**Файлы**:
- `forge-service/internal/service/code_generator.go`
- `forge-service/internal/templates/check_template.go`

### День 45: Metrics Service

#### Этап 23.1: Сбор метрик (День 45, утро)
**Ветка**: `feature/metrics-service`  
**Коммит**: `feat(metrics): implement metrics service`

**Задачи**:
- Сбор метрик из всех сервисов через gRPC
- Экспорт метрик в формате Prometheus
- HTTP endpoint `/metrics`

**Файлы**:
- `metrics-service/internal/collector/collector.go`
- `metrics-service/internal/handler/http/handler.go`

---

## Часть 7: CLI (Command Line Interface) (Дни 46-50)

### День 46-47: Архитектура и команды CLI

#### Этап 24.1: Проектирование CLI (День 46, утро)
**Ветка**: `feature/cli-architecture`  
**Коммит**: `feat(cli): design CLI architecture`

**Задачи**:
- Выбор фреймворка: `cobra` + `viper`
- Определение структуры команд
- Поддержка конфигурационных файлов
- Поддержка переменных окружения
- Автодополнение команд

**Структура команд**:
```
uptimeping
├── auth
│   ├── login
│   ├── logout
│   ├── register
│   ├── api-key
│   │   ├── create
│   │   ├── list
│   │   └── revoke
│   └── status
├── config
│   ├── get
│   ├── create
│   ├── update
│   ├── delete
│   └── list
├── checks
│   ├── run
│   ├── status
│   ├── history
│   └── list
├── incidents
│   ├── list
│   ├── get
│   ├── acknowledge
│   └── resolve
├── notification
│   ├── channels
│   │   ├── add
│   │   ├── remove
│   │   └── list
│   └── test
├── forge
│   ├── generate
│   └── validate
└── config
    ├── init
    └── view
```

**Файлы**:
- `cli/cmd/root.go` - корневая команда
- `cli/cmd/auth.go` - команды аутентификации
- `cli/cmd/config.go` - команды конфигурации
- `cli/cmd/checks.go` - команды проверок
- `cli/cmd/incidents.go` - команды инцидентов
- `cli/cmd/notification.go` - команды уведомлений
- `cli/cmd/forge.go` - команды Forge

#### Этап 24.2: Конфигурация и аутентификация (День 46, вечер)
**Ветка**: `feature/cli-config-auth`  
**Коммит**: `feat(cli): implement configuration and authentication`

**Задачи**:
- Реализовать команду `uptimeping config init` - инициализация конфига
- Поддержка конфигурационных файлов (YAML/JSON)
- Реализовать команду `uptimeping auth login` - интерактивный логин
- Сохранение токенов в защищенном хранилище
- Автоматическое обновление токенов

**Файлы**:
- `cli/internal/config/config.go`
- `cli/internal/auth/auth.go`
- `cli/internal/store/token_store.go`

**Алгоритм `auth login`**:
1. Запрос email и password
2. Вызов Auth Service API
3. Сохранение токенов в `~/.uptimeping/tokens`
4. Сохранение конфигурации в `~/.uptimeping/config.yaml`

#### Этап 24.3: Команды управления проверками (День 47, утро)
**Ветка**: `feature/cli-check-commands`  
**Коммит**: `feat(cli): implement check management commands`

**Задачи**:
- `uptimeping config create` - создание новой проверки
- `uptimeping config get <id>` - получение конфигурации
- `uptimeping config update <id>` - обновление проверки
- `uptimeping config list` - список проверок с фильтрацией
- `uptimeping checks run <id>` - ручной запуск проверки
- `uptimeping checks status <id>` - статус проверки
- `uptimeping checks history <id>` - история выполнения

**Файлы**:
- `cli/cmd/config.go`
- `cli/cmd/checks.go`
- `cli/internal/client/config_client.go`

#### Этап 24.4: Команды инцидентов и уведомлений (День 47, вечер)
**Ветка**: `feature/cli-incident-notification`  
**Коммит**: `feat(cli): implement incident and notification commands`

**Задачи**:
- `uptimeping incidents list` - список инцидентов с фильтрами
- `uptimeping incidents get <id>` - детали инцидента
- `uptimeping incidents acknowledge <id>` - подтверждение инцидента
- `uptimeping notification channels add` - добавление канала уведомлений
- `uptimeping notification test` - тестовая отправка уведомления

**Файлы**:
- `cli/cmd/incidents.go`
- `cli/cmd/notification.go`
- `cli/internal/client/incident_client.go`

### День 48: Интеграция с Forge и продвинутые возможности

#### Этап 25.1: Команды Forge (День 48, утро)
**Ветка**: `feature/cli-forge-commands`  
**Коммит**: `feat(cli): implement forge commands`

**Задачи**:
- `uptimeping forge generate --proto=path/to/file.proto` - генерация конфига из .proto
- `uptimeping forge validate --proto=path/to/file.proto` - валидация proto файла
- Интерактивный режим для настройки параметров проверки
- Поддержка шаблонов для разных типов проверок

**Файлы**:
- `cli/cmd/forge.go`
- `cli/internal/client/forge_client.go`

#### Этап 25.2: Продвинутые возможности CLI (День 48, вечер)
**Ветка**: `feature/cli-advanced`  
**Коммит**: `feat(cli): add advanced CLI features`

**Задачи**:
- Автодополнение команд для bash/zsh/fish
- Цветной вывод и табличное форматирование
- Поддержка форматов вывода: JSON, YAML, таблица
- Команда `uptimeping completion` - генерация completion scripts
- Поддержка контекстов (переключение между окружениями)
- Команда `uptimeping export` - экспорт конфигурации

**Файлы**:
- `cli/internal/output/formatter.go`
- `cli/internal/output/table.go`
- `cli/internal/output/json.go`
- `cli/cmd/completion.go`

### День 49: Тестирование и пакетирование CLI

#### Этап 26.1: Тестирование CLI (День 49, утро)
**Ветка**: `feature/cli-testing`  
**Коммит**: `test(cli): add comprehensive CLI tests`

**Задачи**:
- Интеграционные тесты с моками API
- Тестирование всех команд
- Тестирование обработки ошибок
- Тестирование различных форматов вывода

**Файлы**:
- `cli/tests/integration/cli_test.go`
- `cli/tests/unit/command_test.go`

#### Этап 26.2: Пакетирование и релиз (День 49, вечер)
**Ветка**: `feature/cli-packaging`  
**Коммит**: `feat(cli): setup packaging and release`

**Задачи**:
- Настройка сборки под разные платформы: Linux, macOS, Windows
- Создание DEB/RPM пакетов для Linux
- Создание Homebrew formula для macOS
- Создание Chocolatey package для Windows
- Настройка CI/CD для автоматических релизов

**Файлы**:
- `Makefile` (добавить таргеты для сборки)
- `.goreleaser.yml` - конфигурация GoReleaser
- `scripts/build-cli.sh` - скрипт сборки

### День 50: Документация и финальная интеграция

#### Этап 27.1: Документация CLI (День 50, утро)
**Ветка**: `feature/cli-documentation`  
**Коммит**: `docs(cli): add comprehensive CLI documentation`

**Задачи**:
- `CLI.md` - полная документация по CLI
- `EXAMPLES.md` - примеры использования
- Онлайн help: `uptimeping --help`, `uptimeping <command> --help`
- Man pages
- Интеграция с основной документацией

**Файлы**:
- `docs/CLI.md`
- `docs/EXAMPLES.md`
- `cli/docs/`

#### Этап 27.2: Финальная интеграция и релиз (День 50, вечер)
**Ветка**: `release/v0.1.0`  
**Коммит**: `chore: release v0.1.0`

**Задачи**:
- Интеграционное тестирование всех сервисов (включая CLI)
- Тегирование версии v0.1.0
- Создание changelog с описанием всех фич
- Обновление документации
- Подготовка релизных заметок
- Публикация бинарников CLI на GitHub Releases

---

## Итоговая структура проекта

```
uptimeping-platform/
├── services/
│   ├── api-gateway/
│   ├── auth-service/
│   ├── config-service/
│   ├── scheduler-service/
│   ├── core-service/
│   ├── incident-manager/
│   ├── notification-service/
│   ├── forge-service/
│   ├── metrics-service/
│   └── cli/                    # НОВЫЙ CLI СЕРВИС
│       ├── cmd/
│       │   ├── root.go
│       │   ├── auth.go
│       │   ├── config.go
│       │   ├── checks.go
│       │   ├── incidents.go
│       │   ├── notification.go
│       │   └── forge.go
│       ├── internal/
│       │   ├── auth/
│       │   ├── client/
│       │   ├── config/
│       │   ├── output/
│       │   └── store/
│       ├── tests/
│       └── docs/
├── pkg/
│   ├── config/
│   ├── logger/
│   ├── errors/
│   ├── database/
│   ├── redis/
│   ├── rabbitmq/
│   └── metrics/
├── proto/api/
├── deployments/
│   ├── docker-compose/
│   └── k8s/
├── scripts/
├── docs/
└── tests/
```
